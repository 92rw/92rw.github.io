<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>92rw🚆</title>
  
  
  <link href="https://92rw.github.io/atom.xml" rel="self"/>
  
  <link href="https://92rw.github.io/"/>
  <updated>2025-02-22T12:13:19.841Z</updated>
  <id>https://92rw.github.io/</id>
  
  <author>
    <name>92rw🚆</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ThymeLeaf学习笔记</title>
    <link href="https://92rw.github.io/posts/5b51365f.html"/>
    <id>https://92rw.github.io/posts/5b51365f.html</id>
    <published>2025-02-20T09:00:00.000Z</published>
    <updated>2025-02-22T12:13:19.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="产生背景">产生背景</h2><ol><li><strong>J</strong>ava<strong>S</strong>erver<strong>P</strong>ages 的 .jsp 文件，代码中既有页面布局的静态元素，又有交互后端数据的动态元素，代码维护不方便</li><li>浏览器解释 html 时会忽略未定义的标签属性，因此某些标签可以根据后端返回值动态变换</li><li>Spring 提供了 <code>Model</code> 对象的 <code>addAttribute(String attributeName, Object attributeValue) </code> 方法，在控制器（Controller）方法中传递数据到视图</li><li>Springboot 使用 “<strong>习惯优于配置</strong>” ，集成了 ThymeLeaf 引擎，可以通过 <code>spring-boot-starter-thymeleaf</code> 实现自动配置</li></ol><h2 id="交互方式">交互方式</h2><h3 id="在后端依赖文件引入">在后端依赖文件引入</h3><p>使用Maven的项目，在pom.xml文件加入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用Gradle的项目，在 gradle.build 文件加入</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-thymeleaf&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在html文件中加入标签">在html文件中加入标签</h3><p>对于使用 Thymeleaf 的模板文件，<strong>Thymeleaf 的语法是基于 XML 的</strong>，因此需要在文件的根元素 <code>&lt;html&gt;</code> 中加上 <code>xmlns</code> 声明</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Thymeleaf Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;message&#125;&quot;</span>&gt;</span>Default message<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于标准的 HTML5 文件（即 <code>&lt;!DOCTYPE html&gt;</code>），它本身并不需要严格遵循 XHTML 的语法要求，因此可以省略命名空间声明，直接使用 Thymeleaf 标签和功能。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span> <span class="comment">&lt;!-- 设置字符编码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Thymeleaf Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;message&#125;&quot;</span>&gt;</span>Default message<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出获取变量值用 <code>$</code> 符号,对于javaBean的话使用 <code>变量名.属性名</code> 方式获取,这点和 <code>EL</code> 表达式一样。另外 <code>$</code> 表达式只能写在th标签内部，否则不生效。上面例子就是使用 <code>th:text</code> 标签的值替换 <code>h1</code> 标签里面的值，原有的 <code>Default message</code> 仅用于前端开发时展示用</p><h2 id=""></h2><h2 id="Thymeleaf语法">Thymeleaf语法</h2><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">th:</span>属性名=<span class="string">&quot;标准表达式&quot;</span></span><br></pre></td></tr></table></figure><h3 id="代表性属性名">代表性属性名</h3><table><thead><tr><th>属性名</th><th>功能</th></tr></thead><tbody><tr><td>text</td><td>普通字符串</td></tr><tr><td>utext</td><td>转义文本</td></tr><tr><td>value</td><td>设置文本框的值</td></tr><tr><td>if/each</td><td>条件表达式</td></tr><tr><td>th:with</td><td>定义常量</td></tr><tr><td>action</td><td>指定表单的提交地址</td></tr><tr><td>object</td><td>设置绑定到表单元素的 Java 对象</td></tr><tr><td>field</td><td>设置元素的 id 属性或扮演 id 属性角色的属性</td></tr><tr><td>th:(~)append</td><td>追加(attr属性、class类、style样式)</td></tr></tbody></table><h3 id="标准表达式">标准表达式</h3><p>Thymeleaf 使用的标准表达式有四种类型：</p><table><thead><tr><th>类型名</th><th>书写方法</th></tr></thead><tbody><tr><td>变量表达式</td><td>${…}</td></tr><tr><td>选择变量表达式</td><td>*{…}</td></tr><tr><td>消息表达式</td><td>#{…}</td></tr><tr><td>链接 URL 表达式</td><td>@{…}</td></tr></tbody></table><p>此外，可进行算数、比较、条件、真假运算</p><p>例如 <code>th:with=&quot;isEven=($&#123;prodStat.count&#125; % 2 == 0)&quot;</code></p><table><thead><tr><th>分类</th><th>实例</th></tr></thead><tbody><tr><td>if-then</td><td>(if) ? (then)</td></tr><tr><td>if-then-else</td><td>(if) ? (then) : (else)</td></tr><tr><td>Default</td><td>(value) ?: (defaultvalue)</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">条件表达式if/unless</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;comments.html&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/product/comments(prodId=$&#123;prod.id&#125;)&#125;&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;not #lists.isEmpty(prod.comments)&#125;&quot;</span>&gt;</span>view<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;comments.html&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/comments(prodId=$&#123;prod.id&#125;)&#125;&quot;</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;#lists.isEmpty(prod.comments)&#125;&quot;</span>&gt;</span>view<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:switch</span>=<span class="string">&quot;$&#123;user.role&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;&#x27;admin&#x27;&quot;</span>&gt;</span>User is an administrator<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;#&#123;roles.manager&#125;&quot;</span>&gt;</span>User is a manager<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:switch</span>=<span class="string">&quot;$&#123;user.role&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;&#x27;admin&#x27;&quot;</span>&gt;</span>User is an administrator<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;#&#123;roles.manager&#125;&quot;</span>&gt;</span>User is a manager<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;*&quot;</span>&gt;</span>User is some other thing<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="-2"></h3><h3 id="使用案例">使用案例</h3><p>消息表达式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;Welcome to our application, &#x27; + $&#123;user.name&#125; + &#x27;!&#x27;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 更简单的表达式，但是|…|中只能包含变量表达式$&#123;…&#125;，不能包含其他常量、条件表达式等 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;|Welcome to our application, $&#123;user.name&#125;!|&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:utext</span>=<span class="string">&quot;#&#123;home.welcome($&#123;session.user.name&#125;)&#125;&quot;</span>&gt;</span> Welcome to our grocery store, Sebastian Pepper!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:utext</span>=<span class="string">&quot;#&#123;$&#123;welcomeMsgKey&#125;($&#123;session.user.name&#125;)&#125;&quot;</span>&gt;</span> Welcome to our grocery store, Sebastian Pepper!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>选择变量表达式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;session.user&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;firstName&#125;&quot;</span>&gt;</span>Sebastian<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Surname: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;lastName&#125;&quot;</span>&gt;</span>Pepper<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Nationality: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">*&#123;nationality&#125;</span>&quot;&gt;</span>Saturn<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.user.firstName&#125;&quot;</span>&gt;</span>Sebastian<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Surname: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.user.lastName&#125;&quot;</span>&gt;</span>Pepper<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Nationality: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.user.nationality&#125;&quot;</span>&gt;</span>Saturn<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 也可用选择变量表达式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;session.user.name&#125;&quot;</span>&gt;</span>Sebastian<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Surname: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;session.user.surname&#125;&quot;</span>&gt;</span>Pepper<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Nationality: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;session.user.nationality&#125;&quot;</span>&gt;</span>Saturn<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p>在标签中加入 <code>th:block</code> 使编译前不可见</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.login&#125;&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.name&#125;&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.address&#125;&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/*/ &lt;/th:block&gt; /*/--&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入外部链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;http://www.baidu.com&#125;&quot;</span>&gt;</span>绝对路径<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/&#125;&quot;</span>&gt;</span>相对路径<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;css/bootstrap.min.css&#125;&quot;</span>&gt;</span>Content路径,默认访问static下的css文件夹<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>表格处理</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/example&#125;&quot;</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;User&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;name&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;age&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>th:action 指定提交表单的方式。th:object 指定要绑定的对象，th:field 则映射到绑定对象的字段。<br>因此，th:object 和 th:field 通常作为一个集合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/example&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">submitForm</span><span class="params">(<span class="meta">@ModelAttribute(&quot;User&quot;)</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里，user对象会自动包含表单提交的数据</span></span><br><span class="line">        <span class="comment">// 你可以直接访问user.getName() 和 user.getAge()</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(user.getName()); <span class="comment">// 输出表单提交的name</span></span><br><span class="line">        System.out.println(user.getAge());  <span class="comment">// 输出表单提交的age</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>; <span class="comment">// 返回到视图页面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式在Spring Controller方法中接收一个完整的<code>User</code>对象，而不必手动接收每个单独的字段（<code>name</code>和<code>age</code>）。Spring的<code>@ModelAttribute</code>会自动绑定表单中的数据到对应的Java对象上。</p>]]></content>
    
    
    <summary type="html">前后端交互的方式，在服务器端完成渲染</summary>
    
    
    
    <category term="Coding" scheme="https://92rw.github.io/categories/Coding/"/>
    
    
    <category term="编程" scheme="https://92rw.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从零开始：ideFx开发手记</title>
    <link href="https://92rw.github.io/posts/fa24710a.html"/>
    <id>https://92rw.github.io/posts/fa24710a.html</id>
    <published>2024-03-31T22:00:00.000Z</published>
    <updated>2025-02-22T12:13:19.841Z</updated>
    
    <content type="html"><![CDATA[<p>项目链接：<a href="https://github.com/92rw/ideFx">92rw/ideFx: Use JavaFX to create simple IDE (github.com)</a></p><h2 id="项目背景">项目背景</h2><p>我在学习 Java 语言的最初几节课，是通过记事本编写一个 <code>.java</code> 格式的文件，然后在命令行中通过 <code>javac</code> 指令编译成 <code>.class</code> 字节码文件，然后通过命令行的 <code>java</code> 指令运行得到效果。然后我接触到了 IntelliJ IDEA 这样的集成开发环境（IDE），大大提到了编码效率。当时对这种程序实现自动构建运行环境、简化编译和运行的原理十分感兴趣。</p><p>在学习 Java 图形化编程之后，我被最新的 JavaFX 技术所吸引。因为封装了很多基本的 GUI 组件和功能，可以更加关注于设计思路和具体的实现。因此我决定使用 JavaFX 技术模拟 IntelliJ IDEA 写一个项目，同时检验我的编码水平。</p><p>虽然我注册 Github 账号已经五年多，但是我之前对 Git 版本控制确实了解不深。参考其他项目的开发架构，我将最新的代码上传到 Dev 分支，测试稳定后 <code>pull request</code> 给 main 分支，防止开发版本的错误传递到正式版本。</p><h2 id="实现功能">实现功能</h2><ul><li>初始界面可以对加载到 ideFx 程序中的项目文件夹进行集中管理</li><li>支持对项目目录下的 <code>.java</code> 文件进行编译、运行</li><li>支持对项目目录下的 <code>.class</code> 文件进行反编译</li><li>进入在项目目录下的文件实现文件操作和文本编辑</li><li>在文本编辑器中，对 java 语言的关键词高亮显示</li><li>在控制台输出模块，用不同的颜色标注显示信息的类型</li><li>除了用户在系统环境变量中配置的 JDK，还可以设置为其他版本的JDK用于测试</li><li>用户可切换窗体的显示效果</li></ul><h2 id="项目架构">项目架构</h2><p>项目目录结构如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">│  <span class="selector-class">.gitattributes</span></span><br><span class="line">│  <span class="selector-class">.gitignore</span></span><br><span class="line">│  LICENSE</span><br><span class="line">│  mvnw</span><br><span class="line">│  mvnw<span class="selector-class">.cmd</span></span><br><span class="line">│  pom<span class="selector-class">.xml</span></span><br><span class="line">│  README<span class="selector-class">.md</span></span><br><span class="line">│</span><br><span class="line">├─<span class="selector-class">.idea</span></span><br><span class="line">│      <span class="selector-class">.gitignore</span></span><br><span class="line">│      compiler<span class="selector-class">.xml</span></span><br><span class="line">│      encodings<span class="selector-class">.xml</span></span><br><span class="line">│      jarRepositories<span class="selector-class">.xml</span></span><br><span class="line">│      misc<span class="selector-class">.xml</span></span><br><span class="line">│      uiDesigner<span class="selector-class">.xml</span></span><br><span class="line">│      vcs<span class="selector-class">.xml</span></span><br><span class="line">│      workspace<span class="selector-class">.xml</span></span><br><span class="line">│</span><br><span class="line">├─<span class="selector-class">.mvn</span></span><br><span class="line">│  └─wrapper</span><br><span class="line">│          maven-wrapper<span class="selector-class">.jar</span></span><br><span class="line">│          maven-wrapper<span class="selector-class">.properties</span></span><br><span class="line">│</span><br><span class="line">└─<span class="attribute">src</span></span><br><span class="line">   └─<span class="selector-tag">main</span></span><br><span class="line">       ├─java</span><br><span class="line">       │  │  module-info<span class="selector-class">.java</span></span><br><span class="line">       │  │</span><br><span class="line">       │  └─com</span><br><span class="line">       │      └─rwj</span><br><span class="line">       │          └─idefx</span><br><span class="line">       │              │  FontLoader<span class="selector-class">.java</span></span><br><span class="line">       │              │  JavaSyntaxHighlighter<span class="selector-class">.java</span></span><br><span class="line">       │              │  Launcher<span class="selector-class">.java</span></span><br><span class="line">       │              │</span><br><span class="line">       │              ├─controller</span><br><span class="line">       │              │      ApplicationController<span class="selector-class">.java</span></span><br><span class="line">       │              │      ProjectController<span class="selector-class">.java</span></span><br><span class="line">       │              │      RuntimeController<span class="selector-class">.java</span></span><br><span class="line">       │              │</span><br><span class="line">       │              ├─model</span><br><span class="line">       │              │      AppConfig<span class="selector-class">.java</span></span><br><span class="line">       │              │      CustomizeModel<span class="selector-class">.java</span></span><br><span class="line">       │              │      ExecutionResult<span class="selector-class">.java</span></span><br><span class="line">       │              │      FileModel<span class="selector-class">.java</span></span><br><span class="line">       │              │      OSType<span class="selector-class">.java</span></span><br><span class="line">       │              │      ProjectConfig<span class="selector-class">.java</span></span><br><span class="line">       │              │      ThemeInfo<span class="selector-class">.java</span></span><br><span class="line">       │              │</span><br><span class="line">       │              └─view</span><br><span class="line">       │                      ContextMenuBuilder<span class="selector-class">.java</span></span><br><span class="line">       │                      CreateProjectDialog<span class="selector-class">.java</span></span><br><span class="line">       │                      DialogView<span class="selector-class">.java</span></span><br><span class="line">       │                      MainView<span class="selector-class">.java</span></span><br><span class="line">       │                      ProjectListCell<span class="selector-class">.java</span></span><br><span class="line">       │                      StartView<span class="selector-class">.java</span></span><br><span class="line">       │</span><br><span class="line">       └─resources</span><br><span class="line">           ├─com</span><br><span class="line">           │  └─rwj</span><br><span class="line">           ├─fonts</span><br><span class="line">           │  └─jetbrains</span><br><span class="line">           │          JetBrainsMono-Medium<span class="selector-class">.ttf</span></span><br><span class="line">           │          JetBrainsMono-MediumItalic<span class="selector-class">.ttf</span></span><br><span class="line">           │</span><br><span class="line">           └─themes</span><br><span class="line">               └─codearea</span><br><span class="line">                       dracula<span class="selector-class">.css</span></span><br><span class="line">                       light<span class="selector-class">.css</span></span><br><span class="line">                       monokai<span class="selector-class">.css</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结的经验">总结的经验</h2><ol><li><p>关注点分离</p><ul><li>MVC 模式由哪一层处理用户需求？当显示给用户的信息都需要等待后端返回结果时，应当由 Controller 层做主导，返回 View 层的内容；当程序主要依赖 UI 组件的用户交互时，可以由 View 层做主导，Controller 层作为中间层。</li><li>MVVM 模式究竟意味着什么：ViewModel 作为中间层，虽然不能直接操作 View 层的组件，但是可以通过“绑定”来改变 View 层组件显示的信息。</li></ul></li><li><p>编写 Java 程序时的感悟</p><ul><li>当代码过长时，将某一个功能相关的代码整体写入一个方法体，以便通过方法的说明了解实现了哪些内容，</li><li>使用建造者模式封装需要传入的参数，方便后期调整时的代码阅读。</li><li>“DTO”类作为数据传输的类，在普通的数据传递时也可以使用：编译异常除了可以通过转为运行时异常，也可以用一个“DTO”类捕获；程序正常运行时的结果，除了直接输出字符串，也可以用“DTO”类传递。</li></ul></li><li><p>虽然在 IntelliJ IDEA 新建的 JavaFX项目默认将组件的信息和调用的方法写在自动生成的 <code>.xml</code> 文件中，可以通过 SceneBuilder 可视化地设定布局效果，然而这种方式并不完美</p><ul><li>SceneBuilder 的很多组件都只有默认样式，如果要追求更好的显示效果，仍需要在布局格局效果后自行设计</li><li>虽然 UI组件 的配置单独提取出来，但是 Controller 层将用户交互、调用后端的代码都进行集中管理，违背了单一职责原则</li></ul></li><li><p>加深对数据结构的理解</p><ul><li>“文件树” 对应的树结构，通过递归访问对应目录获取节点。为了防止文件夹深度过高造成的访问速度受影响，需要通过“递归深度”这个概念来进行控制。</li><li>列表中的元素，可以包含多个不同的属性参数。在UI组件调用时，可以给不同属性指定各自的显示效果。这种对象类似于前后端交互时的“分页”对象</li></ul></li><li><p>对项目结构的认识</p><ul><li>在项目设计时，考虑到项目结构本身较为简单，引入过多的依赖会造成结构臃肿、拖慢运行时长。因此在 View 层通过调用单例类静态方法的方式操作 Controller 层，没有通过 Spring 框架击中管理。</li><li>在实际的代码编写中，通过自己的方式实现了依赖注入（在 StartView 显示 UI 界面前，先加载项目初始化信息）。只是没有像 Spring 框架那样把 Controller 层接口化，仍然通过调用具体类的方式实现。</li></ul></li></ol><h2 id="吸取的教训">吸取的教训</h2><ol><li>软件开发应当在设计、架构上投入更多的时间，代码只是实现设计的方式。前期设计不周全会导致后期大面积的修改调试。</li><li>应当提前考虑变量之间的关系。当UI组件之间有一些相互操作的代码逻辑之后，要想将一些功能另外提取到新的类已经变得十分困难，增加新功能只会让现有代码变得更复杂难以阅读。</li><li>Java 新版本要求导入的包都实现模块化，否则无法顺利打包。因此在引入新的依赖时要注意和当前环境变量是否匹配。</li><li>随着项目变大，对某个业务流程进行“微调”越来越难，很多时间被用于整理过去写过的代码。因此及时写项目文档很重要，能帮助快速定位到需要检查的方法。</li></ol>]]></content>
    
    
    <summary type="html">记录我在Java项目开发实战中总结的经验和教训</summary>
    
    
    
    <category term="Blog" scheme="https://92rw.github.io/categories/Blog/"/>
    
    
    <category term="个人网站" scheme="https://92rw.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>位运算的性质和使用</title>
    <link href="https://92rw.github.io/posts/f3fc75ba.html"/>
    <id>https://92rw.github.io/posts/f3fc75ba.html</id>
    <published>2024-02-02T18:00:00.000Z</published>
    <updated>2024-02-02T18:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="机器数的表示">机器数的表示</h2><p>在我的Java学习笔记第四篇《<a href="https://github.com/92rw/Java-Study-Notes/blob/main/JavaNote/Studynote04_Numeral.md">进制和数学数算</a>》中，简单地提到了计算机三码运算的过程。数据在计算机中的形式称为机器数，其表示方式可以有四种：原码表示、反码表示、补码表示、移码表示。</p><p>用8位二进制数比较各码值的区别</p><table><thead><tr><th>十进制</th><th>二进制原码表示</th><th>二进制反码表示</th><th>二进制补码表示</th><th>二进制移码表示</th></tr></thead><tbody><tr><td>127</td><td>01111111</td><td>01111111</td><td>0111 1111</td><td>11111111</td></tr><tr><td>126</td><td>01111110</td><td>01111110</td><td>01111110</td><td>11111110</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td><td>……</td></tr><tr><td>1</td><td>00000001</td><td>00000001</td><td>00000001</td><td>10000001</td></tr><tr><td>0</td><td>00000000</td><td>00000000</td><td>00000000</td><td>10000000</td></tr><tr><td>-0</td><td>10000000</td><td>11111111</td><td>00000000</td><td>10000000</td></tr><tr><td>-1</td><td>1000 0001</td><td>11111110</td><td>11111111</td><td>01111111</td></tr><tr><td>-2</td><td>10000010</td><td>11111101</td><td>11111110</td><td>01111110</td></tr><tr><td>-3</td><td>10000011</td><td>11111100</td><td>11111101</td><td>01111101</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td><td>……</td></tr><tr><td>-127</td><td>11111111</td><td>10000000</td><td>10000001</td><td>00000001</td></tr><tr><td>-128</td><td>无法表示</td><td>无法表示</td><td>10000000</td><td>00000000</td></tr></tbody></table><p>原码：按照数字的绝对值用二进制表示，符号位用 0 表示正数，1 表示负数。原码是二进制表示中最简单的形式，但存在+0和-0的不同。</p><p>补码：原码保留符号位，其他位取反后+1，位运算相反数公式 -x = ~x + 1。补码解决了0问题，并且能表示整数最小值。在Java中可以通过<code>Integer.toBinaryString</code> 方法得到。</p><p>移码：把负数绝对值的二进制表示取反，然后再加上一个偏移值（offset）。可以直接通过码值大小来确定真值大小</p><h3 id="小数的表示方式">小数的表示方式</h3><p>浮点数普遍使用IEEE 754工业标准，约定对于32位单精度浮点数，符号位S为1位，阶码长度（指数位E）为8位，尾数长度（分数位N）为23位</p><p><img src="https://static-resources.vercel.app/image/ArticleContents/knowledge/Float_example.png" alt="img"></p><p>如上图要计算小数0.15625的二进制码，首先要把 0.15625 转换成二进制数 0.00101 ，然后小数点右移成为 1.01×2^−3 。因此阶码-3用移码表示，因此阶码为（移位值为127，即用 127+(−3)=124 的二进制值来表示-3） 0111 1100 ；尾数为 010 0000 0000 0000 0000 0000 。</p><p>float格式可以表示的最大正数 (-1)^0 * 2^(254-127) * (2-2^-23) ≈ 3.4 * 10^38</p><h3 id="补码运算的本质">补码运算的本质</h3><p>前段时间在B站学习了视频《<a href="https://www.bilibili.com/av360188836">这个你没听说过的数字系统，能够解决数学中最困难的问题</a>》，里面提到“无限位数字”的概念，这和“舍弃溢出的符号位实现加减运算”这一概念具有相同逻辑性。</p><ul><li><p>十进制负数转二进制：①整体取反②减1后转二进制③整体取反</p></li><li><p>二进制负数转十进制：①整体取反②加1后转十进制③整体取反</p><p>[+001]补=00000001,[-001]补=11111111</p><p>[+127]补=01111111,[-127]补=10000001</p><p>[+045]补=00101101,[-045]补=11010011</p></li></ul><p>上述运算的本质，是二进制数+1后可以向上传递进位，然后抛弃掉溢出的符号位。类似于钟表，往后拨两个小时和往前拨10个小时是一样的，加一是因为还有一位0。</p><p>减法运算就是被减数加上减数的补码，而十进制减法运算8 - 7可以转换为8  + (-10 + 3)，二进制也可以用“比减数高一位的一个计数单位减去<strong>减数</strong>来得到将来要用到加法里面的<strong>加数</strong>”，而**二进制里用高一位的一个计数单位减去正数的补码就相当于绝对值按位求反再末尾加1！！！**例如</p><p>-1可以表示为(10000001)₂除符号位外取反加一(11111110+1)₂得到(11111111)₂，也可以表示为(10000000 - 00000001)₂得到的(11111111)₂</p><p>掌握这个本质就可以直接用原码进行计算了</p><p>10-1=(00001010-00000001)₂=(00001001)₂=9</p><p>10+(-1)=(00001010+11111111)₂=(100001001)₂，高位溢出直接不要了，就变成(00001001)₂=9</p><h2 id="位运算的使用">位运算的使用</h2><p>位运算的运算规则如下：</p><table><thead><tr><th>符号</th><th>描述</th><th>运算规则</th></tr></thead><tbody><tr><td>&amp;</td><td>与AND</td><td>两个位都为1时，结果才为1</td></tr><tr><td>|</td><td>或OR</td><td>两个位都为0时，结果才为0</td></tr><tr><td>^</td><td>异或XOR</td><td>两个位相同为0，相异为1</td></tr><tr><td>~</td><td>取反NOT</td><td>0变1，1变0</td></tr><tr><td>&lt;&lt;</td><td>左移SHL</td><td>各二进位全部左移若干位，高位丢弃，低位补0</td></tr><tr><td>&gt;&gt;</td><td>右移SHR</td><td>各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）</td></tr></tbody></table><p><img src="https://static-resources.vercel.app/image/ArticleContents/knowledge/bitwise-operations.png" alt="位运算图解"></p><p>图片出处：<a href="https://wizardzines.com/comics/bitwise-operations/">bitwise operations (wizardzines.com)</a></p><p>～x = -x - 1：0与-1，1与-2，2与-3……等等。因此，该性质是not操作中最常使用的性质。</p><p>(~x)&amp;x = 0：任意数与它的取反数的and操作结果为0。</p><p>(~x)|x = -1：任意数与它的取反数的or操作结果为-1。</p><p>(~x)^x = -1：任意数与它的取反数的xor操作结果为-1。</p><p>x|0 = x：任意数x与0的or操作结果为x自己。</p><p>x^0 = x：任意数x与0的xor操作结果为x自己。</p><p>x^y^y = x：任意数x与任意数y进行两次xor操作结果为x自己。</p><h3 id="AND操作">AND操作(&amp;)</h3><ul><li><p>判断奇偶数：<code>x &amp; 1 == 1</code>。（注意：这样的逻辑会把0当作偶数，注意设置条件判断）</p></li><li><p>判断第n个二进制位是否为1：<code>(x &amp; (1 &lt;&lt; n) != 0</code></p></li><li><p>去掉低位的1 <code>x &amp; (x-1)</code></p></li><li><p>按字节读取 <code>byte &amp; 0xff</code>，清除字节的高位，将其转换为无符号值。用于在网络编程、文件IO或加密解密等场景中处理二进制数据</p></li><li><p>计算二进制中1的个数（见下方“单数字运算”代码）</p></li></ul><h3 id="OR操作">OR操作(|)</h3><ul><li>生成组合编码，进行状态压缩</li><li>在加密或编码中，将两个字节合并</li></ul><h3 id="XOR操作">XOR操作(^)</h3><ul><li><p>两个整数交换变量名：注意数组的某个下标的值，执行按位异或后将会变0丢失原数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] swap(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    b ^= a;   <span class="comment">// b = b ^ a</span></span><br><span class="line">    a ^= b;   <span class="comment">// a = a ^ b, 此时 a = (a ^ b) ^ a = b</span></span><br><span class="line">    b ^= a;   <span class="comment">// b = b ^ a, 此时 b = (b ^ a) ^ b = a</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;a, b&#125;;  <span class="comment">// 返回交换后的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数据判重：连续的xor操作会自行抵销了出现了偶数次的数，剩下的就是不重复的数。经典算法题：<a href="https://leetcode.com/problems/single-number/description/">Single Number</a>、<a href="https://leetcode.com/problems/single-number-ii/description/">Single Number II</a>、<a href="https://leetcode.com/problems/single-number-iii/description/">Single Number III</a>、<a href="https://leetcode.com/problems/missing-number/description/">Missing Number</a></p></li><li><p>数据加密：利用x^y^y = x的性质，可以在使用相同的密钥（私钥）的情况下做一个简单的对称加密，实现将字符串“我爱你”加密为“抺犚俋”（密钥为0xAB），也可以用此密钥对加密后的字符串再进行一次异或运算还原出“我爱你”（注意：简单的异或加密并不是安全的加密方式，它仅提供了基本的混淆。在实际应用中，为了更安全地加密数据，应该使用专门设计的加密算法，如AES、DES等。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;我爱你&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">0xAB</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, len = s.length(); i &lt; len; i++) &#123;</span><br><span class="line">temp += (<span class="type">char</span>)(s.charAt(i) ^ key);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="SHL操作">SHL操作(&lt;&lt;)</h3><ul><li>求某个数和2的n次方乘积 <code>x &lt;&lt; n</code></li><li>注意算数左移会导致高位符号溢出，可能将负数变成很大的正数</li><li>经典算法题：<a href="https://leetcode.com/problems/power-of-two/description/">Power of Two</a>、<a href="https://leetcode.com/problems/power-of-four/description/">Power of Four</a>、<a href="https://leetcode.com/problems/binary-number-with-alternating-bits/description/">Binary Number with Alternating Bits</a></li></ul><h3 id="SHR操作">SHR操作(&gt;&gt;)</h3><ul><li>求某个数和2的n次方的模 <code>x &gt;&gt; n</code>，因为保留符号位，所以对正数负数都能用</li><li>求平均值：为防止溢出，一般使用无符号右移Unsigned Shift Right(&gt;&gt;&gt;) <code>(a + b) &gt;&gt;&gt; 1</code></li></ul><h2 id="二进制位存储数据">二进制位存储数据</h2><p>重要的是分治和移位思想。补充阅读：<a href="https://zhuanlan.zhihu.com/p/37909809">二进制与位运算实用操作汇总（实战篇） - 知乎 (zhihu.com)</a></p><h3 id="单数字运算">单数字运算</h3><p>二进制码可以看作是多个布尔值的集合，因此一个int类型的值可以存放32个只有0/1值的字段。假设一个网站注册时要用户勾选感兴趣的类目，一共有8项。那么这时，就能用一个byte值去表示所有的可能性组合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个保存用户选项的变量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">option</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//初始化为0时，代表没有类目被选中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义好每个条目占用的二进制位</span></span><br><span class="line"><span class="type">int</span> <span class="variable">iteml</span> <span class="operator">=</span> <span class="number">0x01</span>;<span class="comment">//十进制1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">item2</span> <span class="operator">=</span> <span class="number">0x02</span>;<span class="comment">//十进制2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">item3</span> <span class="operator">=</span> <span class="number">0x04</span>;<span class="comment">//十进制4</span></span><br><span class="line"><span class="type">int</span> <span class="variable">item4</span> <span class="operator">=</span> <span class="number">0x08</span>;<span class="comment">//十进制8</span></span><br><span class="line"><span class="type">int</span> <span class="variable">item5</span> <span class="operator">=</span> <span class="number">0x10</span>;   <span class="comment">// 十进制表示为 16，二进制表示为 00010000</span></span><br><span class="line"><span class="type">int</span> <span class="variable">item6</span> <span class="operator">=</span> <span class="number">0x20</span>;   <span class="comment">// 十进制表示为 32，二进制表示为 00100000</span></span><br><span class="line"><span class="type">int</span> <span class="variable">item7</span> <span class="operator">=</span> <span class="number">0x40</span>;   <span class="comment">// 十进制表示为 64，二进制表示为 01000000</span></span><br><span class="line"><span class="type">int</span> <span class="variable">item8</span> <span class="operator">=</span> <span class="number">0x80</span>;   <span class="comment">// 十进制表示为 128，二进制表示为 10000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设选中了item2,5,7,8</span></span><br><span class="line">option = item2|item5|item7|item8<span class="comment">//使用or操作实现添加元素</span></span><br></pre></td></tr></table></figure><p>访问元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((option &amp; item1) != <span class="number">0</span>) System.out.println(<span class="string">&quot;item1 被选中&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ((option &amp; item2) != <span class="number">0</span>) System.out.println(<span class="string">&quot;item2 被选中&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ((option &amp; item3) != <span class="number">0</span>) System.out.println(<span class="string">&quot;item3 被选中&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ((option &amp; item4) != <span class="number">0</span>) System.out.println(<span class="string">&quot;item4 被选中&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ((option &amp; item5) != <span class="number">0</span>) System.out.println(<span class="string">&quot;item5 被选中&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ((option &amp; item6) != <span class="number">0</span>) System.out.println(<span class="string">&quot;item6 被选中&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ((option &amp; item7) != <span class="number">0</span>) System.out.println(<span class="string">&quot;item7 被选中&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ((option &amp; item8) != <span class="number">0</span>) System.out.println(<span class="string">&quot;item8 被选中&quot;</span>);</span><br></pre></td></tr></table></figure><p>删除元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//and目标的取反，仅会影响 option 中与 item5 和 item8 对应的位。其他位的数值保持不变。</span></span><br><span class="line">option &amp;= ~item5;</span><br><span class="line">option &amp;= ~item8;</span><br></pre></td></tr></table></figure><p>反选元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option = ~option;</span><br></pre></td></tr></table></figure><p>删除最小元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option &amp;= option - <span class="number">1</span>;<span class="comment">//将最右侧的1设置成0</span></span><br></pre></td></tr></table></figure><p>求集合大小</p><ul><li><p>本质上就是统计二进制数中1的个数，就是多次求出最末端的1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">        ++r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>纯位运算方法，可以更快解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = option &amp; <span class="number">0xFF</span>;<span class="comment">//只保留 option 的最低8位，将高位都设为0。</span></span><br><span class="line">x = (x &amp; <span class="number">0x55</span>) + ((x &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55</span>);<span class="comment">//对 x 的低4位进行位运算。它提取奇数位（位置1、3、5、7），并将它们与偶数位（向右移动1位）相加。常数 0x55 用于屏蔽和分离这些位。</span></span><br><span class="line">x = (x &amp; <span class="number">0x33</span>) + ((x &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33</span>);<span class="comment">//每4个二进制数计算1的个数</span></span><br><span class="line">x = (x &amp; <span class="number">0x0F</span>) + ((x &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F</span>);<span class="comment">//每8个二进制数统计1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>集合间的运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重新定义3个集合</span></span><br><span class="line">option1 = item1|item2|item4|item5;</span><br><span class="line">option2 = item3|item6;</span><br><span class="line">option3 = item5|item6|item7;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现两个集合交集</span></span><br><span class="line">option = option1 &amp; option3;<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现两个集合并集</span></span><br><span class="line">option = option2 | option3;<span class="comment">//3,5,6,7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现集合2减去集合3的差集</span></span><br><span class="line">option = option2 &amp; ~option3;<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现集合2和集合3的非重叠集（交集的补集）</span></span><br><span class="line">option = option2 ^ option3;<span class="comment">//3,5,7</span></span><br></pre></td></tr></table></figure><p>经典算法题：<a href="https://leetcode.com/problems/subsets/description/">Subsets</a>、<a href="https://leetcode.com/problems/maximum-product-of-word-lengths/description/">Maximum Product of Word Lengths</a>、<a href="https://leetcode.com/problems/letter-case-permutation/description/">Letter Case Permutation</a>、<a href="https://leetcode.com/problems/repeated-dna-sequences/description/">Repeated DNA Sequences</a></p><h3 id="位集">位集</h3><p>用bit组成的数组来存放值，用bit状态1、0代表存在、不存在，取值和存值操作都用位运算</p><p>限制是必须为连续范围且不能过大。好处是极大的节省空间，因为1个数字只占用1个bit的空间</p><p>参考视频资料：<a href="https://www.bilibili.com/av744723379">算法讲解032【必备】位图</a>，练习题：<a href="https://leetcode.com/problems/design-bitset/">Design Bitset - LeetCode</a></p>]]></content>
    
    
    <summary type="html">单个数字也能实现数据的操作</summary>
    
    
    
    <category term="Algorithm" scheme="https://92rw.github.io/categories/Algorithm/"/>
    
    
    <category term="算法" scheme="https://92rw.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>求解质数和斐波那契数</title>
    <link href="https://92rw.github.io/posts/14ba35a0.html"/>
    <id>https://92rw.github.io/posts/14ba35a0.html</id>
    <published>2024-01-15T00:00:00.000Z</published>
    <updated>2024-01-15T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>质数和斐波那契数列之间并没有直接的数学关系或依赖关系。质数和斐波那契数列是两个独立的数学概念，描述了不同的数学性质。</p><p><strong>质数：</strong> 质数是大于1且只能被1和自身整除的正整数。例如，2、3、5、7等都是质数。质数在数论中有着重要的地位，并涉及到诸多有趣的性质和研究领域。</p><p><strong>斐波那契数列：</strong> 斐波那契数列是一个数学序列，其定义是从第三项开始，每一项都是前两项的和。形式上，斐波那契数列可以表示为：<code>F(n) = F(n−1) + F(n−2)</code>，其中 <code>F(0)=0, F(1)=1</code>。</p><p>虽然在数学上它们没有直接的联系，但在一些编程和算法问题中，可能会出现同时涉及到质数和斐波那契数列的情况。例如，一些算法问题可能要求同时判断某个数是不是质数，同时它的斐波那契数列中的位置是否也是质数。这种联系通常是在特定问题背景下引入的，而不是数学本身的关系。</p><h2 id="质数">质数</h2><p>许多年前在 <a href="https://zh.wikipedia.org/zh-sg/%E7%B7%A8%E7%A8%8B%E9%9A%A8%E6%83%B3">编程随想</a> 的博客读到过文章 <a href="https://program-think.blogspot.com/2011/12/prime-algorithm-1.html?m=1">求质数算法的 N 种境界- 试除法和初级筛法</a>，当时就感慨自己的思路不够开阔，作者在文章中分别给出了算法和数据结构的使用境界，总结如下：</p><p>一般人的思路是通过试除法来计算质数，然而筛法计算速度更为优越：</p><ol><li><strong>试除法：</strong><ul><li>境界1：最简单的试除法，从2一直尝试到x-1，效率最差。</li><li>境界2：优化为尝试到x/2，减少工作量。</li><li>境界3：只尝试奇数，因为质因数除2外都是奇数。</li><li>境界4：尝试到√x，因为成对的因数一个小于等于√x，另一个大于等于√x。</li><li>境界5：尝试小于√x的质数，以空间换时间，提高效率。</li></ul></li><li><strong>埃拉托斯特尼筛法（Sieve of Eratosthenes）：</strong><ul><li>基本思想是从小到大枚举每个数，将其所有的倍数标记为合数。通过不断筛去合数，剩下的即为质数。</li><li>在第一次枚举时，标记所有的合数。</li><li>在后续枚举中，如果当前数没有被标记，那么它就是质数，然后标记其所有的倍数。</li><li></li></ul></li><li><strong>筛法的优化考虑：</strong><ul><li>如何确定质数的分布范围，涉及素数定理的应用。</li><li>如何设计存储容器，从整型容器到按位存储的布尔型容器，以提高空间性能。</li></ul></li></ol><p>在数据结构的使用上，也分为多重境界：</p><h4 id="境界1：整型容器">境界1：整型容器</h4><ul><li><strong>设计：</strong> 使用整型数组，每个元素表示一个自然数，通过标记是否为质数。</li><li><strong>特点：</strong> 简单直观，但浪费内存空间，可能导致频繁的内存分配和释放。</li><li><strong>适用场景：</strong> 适用于小范围的质数筛选。</li></ul><h4 id="境界2：布尔型容器">境界2：布尔型容器</h4><ul><li><strong>设计：</strong> 使用布尔型数组，每个元素表示一个自然数，通过标记是否为质数（true表示是质数，false表示是合数）。</li><li><strong>特点：</strong> 减少了内存浪费，避免了频繁的内存分配和释放。</li><li><strong>适用场景：</strong> 适用于中等范围的质数筛选，相比境界1更节省内存。</li></ul><h4 id="境界3：按位存储容器">境界3：按位存储容器</h4><ul><li><strong>设计：</strong> 使用字节数组，每个字节存储多个自然数的质数信息，通过位运算标记是否为质数。</li><li><strong>特点：</strong> 进一步减少了内存占用，提高了空间利用率，适用于大范围的质数筛选。</li><li><strong>适用场景：</strong> 适用于大规模的质数筛选，具有更高的空间性能。</li></ul><p>总体比较：</p><ul><li>境界1最简单，但内存浪费大，性能差。</li><li>境界2减少了内存浪费，性能相对较好，适用于中等规模的问题。</li><li>境界3在内存占用上进一步优化，适用于处理大规模的问题。</li></ul><p>在实际应用中，选择合适的境界取决于问题规模和性能需求。随着问题规模的增加，通常会选择更高境界的容器以提高性能。</p><h2 id="斐波那契数列">斐波那契数列</h2><p>在开源电子书《Hello算法》的 <a href="https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion/#3_1">迭代与递归</a> 章节中，给出了递归实现斐波那契数列的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 斐波那契数列：递归 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 终止条件 f(1) = 0, f(2) = 1</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递归调用 f(n) = f(n-1) + f(n-2)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 返回结果 f(n)</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而质数计算一般不适合使用递归。递归是一种自调用的方式，适用于问题可以分解为相同类型的子问题的情况。然而，质数判定本质上是一个简单的判断问题，没有自然地分解为相同类型的子问题。</p><p>质数判定通常采用迭代的方式，例如试除法或更高效的算法。递归可能会导致效率低下，因为它需要在每一层递归调用中保存状态，而这种方式可能会在处理大数时导致栈溢出或效率低下。</p><h2 id="算法求解">算法求解</h2><p>ChatGPT 对于算法题“判断某个数是不是质数，同时它的斐波那契数列中的位置是否也是质数” 给出的求解步骤是：</p><ol><li><strong>判断数是否是质数：</strong> 使用常见的质数判定方法，例如试除法或更高效的算法（如 Miller-Rabin 算法）。如果数是质数，进入下一步；否则，停止判断。</li><li><strong>确定数在斐波那契数列中的位置：</strong> 计算斐波那契数列，找到该数在序列中的位置。可以使用迭代或递归的方式计算斐波那契数列。</li></ol><p>ChatGPT给出判断质数的代码是境界4，因为不需要使用额外空间复杂度存储所有质数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimeAndFibonacciPrime</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断一个数是否为质数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= Math.sqrt(num); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算斐波那契数列</span></span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; fib = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        fib.add(<span class="number">0</span>);</span><br><span class="line">        fib.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (fib.size() &lt;= n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> fib.get(fib.size() - <span class="number">1</span>) + fib.get(fib.size() - <span class="number">2</span>);</span><br><span class="line">            fib.add(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fib;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 输入待判断的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">17</span>;  <span class="comment">// 可以根据需要修改这个数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断数是否为质数</span></span><br><span class="line">        <span class="keyword">if</span> (isPrime(number)) &#123;</span><br><span class="line">            System.out.println(number + <span class="string">&quot; is a prime number.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算斐波那契数列，找到位置</span></span><br><span class="line">            ArrayList&lt;Integer&gt; fibSequence = fibonacci(number);</span><br><span class="line">            <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> fibSequence.indexOf(number);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断位置是否为质数</span></span><br><span class="line">            <span class="keyword">if</span> (isPrime(position)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;The position of &quot;</span> + number + <span class="string">&quot; in the Fibonacci sequence is also a prime number.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;The position of &quot;</span> + number + <span class="string">&quot; in the Fibonacci sequence is not a prime number.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(number + <span class="string">&quot; is not a prime number.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">从一道算法题学到的数学知识</summary>
    
    
    
    <category term="Algorithm" scheme="https://92rw.github.io/categories/Algorithm/"/>
    
    
    <category term="算法" scheme="https://92rw.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Summary of year 2023</title>
    <link href="https://92rw.github.io/posts/677b2145.html"/>
    <id>https://92rw.github.io/posts/677b2145.html</id>
    <published>2024-01-03T18:00:00.000Z</published>
    <updated>2024-01-03T18:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What-I-have-done">What I have done</h2><p>In the transformative year of 2023, I embarked on a journey to learn coding and pursue a career in the IT industry. Starting in June, my journey began with watching Java coding videos and meticulously recording my progress on Github. As months passed, I applied my newfound knowledge to successfully reconstruct my website, a testament to my evolving skills. To enhance my algorithmic proficiency, I dedicated time to solving problems on Leetcode.</p><p>November brought a cultural exploration as I visited cities in Northeast China, focusing on the historical relics of the Russo-Japanese War and the architectural heritage of Manchuria. In preparation for this cultural journey, I dedicated time to improving my Japanese language skills by watching relative videos.</p><p>As the saying goes, “Read ten thousand books, travel ten thousand miles.” In 2023, I covered 2167km on railways and 10321km on planes, recognizing the vastness of knowledge yet to be explored. This journey not only broadened my horizons but also revealed the need to continually squeeze time to advance along my chosen path. The year was a realization that there is always more to learn, pushing me to become more skilled and proficient.</p><h2 id="New-Year’s-Words">New Year’s Words</h2><p>I have many to share but my limited vocabulary get in my way. I hope I can write more article in this website, in different language.</p><p>If you observe the season changing of Singapore, you will be depressed because everyday is similar hot weather. It makes me feel like stuck in the loop of summer, I want to change to another city to feel the difference of months. Everyday I can see green trees, but I also want to touch tree buddings in spring, hear sound of stepping on fallen leaves in autumn, and feel the treading on snow.</p><p>What is the meaning of a new year? It marks the earth come to the same position as the day of last year, it’s the beginning of a new calendar. In the coming year, my focus is on doing something different - starting a new chapter by working in an IT company and striving for personal excellence. Despite the challenges and the loop of familiarity, I am determined to break free, embracing the opportunity for growth and change. The new year is not just a continuation but a chance to embark on new endeavors, learn, and evolve.</p>]]></content>
    
    
    <summary type="html">Encapsulating a year of growth in 2023</summary>
    
    
    
    <category term="Blog" scheme="https://92rw.github.io/categories/Blog/"/>
    
    
    <category term="个人网站" scheme="https://92rw.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程语法</title>
    <link href="https://92rw.github.io/posts/db8e2776.html"/>
    <id>https://92rw.github.io/posts/db8e2776.html</id>
    <published>2023-11-09T08:00:00.000Z</published>
    <updated>2023-11-09T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数式接口">函数式接口</h2><p>定义：有且只有一个抽象方法的接口</p><p>可以使用@FunctionalInterface 标识函数式接口</p><ul><li><p>当接口中存在多个抽象方法时，提示：Multiple non-overriding abstract methods found in interface</p></li><li><p>当接口中不存在抽象方法时，提示：No target method found</p></li><li><p>函数式接口可以不带泛型，可以有多个用default修饰的默认实现方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">HspFunction</span>&lt;T, R&gt; &#123;</span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>; <span class="comment">//抽象方法: 表示根据类型T的参数，获取类型R的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数式接口，依然可以有多个默认实现方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ok</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传统的方式实现函数式接口，使用匿名内部类的形式。使用Lambda表达式配合函数式接口可以简化代码：<strong>不关注单个抽象方法的权限，返回值，签名，只关注于该方法的入参和方法体即可。但是仅限于一个抽象方法的接口的匿名内部类的简化情况。</strong></p><table><thead><tr><th>情况</th><th>简化方式</th></tr></thead><tbody><tr><td>Lambda的入参，以前都要指名类型</td><td>其实参数类型也是可以动态推断的，可以不写参数类型</td></tr><tr><td>Lambda的入参，只有一个入参的时候，还是要加上 ()</td><td>可以省略 () 不写，当且仅当一个参数的时候</td></tr><tr><td>Lambda的方法体，只有一个语句的时候（空返回值）</td><td>可以直接省略方法体的{}</td></tr><tr><td>Lambda的方法体，只有一个语句的时候（有返回值）</td><td>也可以直接省略方法体的{}，甚至省略return关键字</td></tr></tbody></table><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/531249053">JDK8新特性第一篇：Lambda表达式 - 知乎 (zhihu.com)</a></p><h3 id="四大函数式接口">四大函数式接口</h3><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>对应程序逻辑的抽象</th><th>具体场景</th></tr></thead><tbody><tr><td>Function</td><td>&lt;出参类型,  入参类型&gt;</td><td>程序中映射逻辑的抽象</td><td>比如我们写得很多的函数：接收入参，返回出参，方法代码块就是一个映射的具体逻辑。</td></tr><tr><td>Predicate</td><td>&lt;入参类型&gt;，test方法的出参为boolean类型</td><td>程序中判断逻辑的抽象</td><td>比如各种if判断，对于一个参数进行各种具体逻辑的判定，最后返回一个if  else能使用的布尔值</td></tr><tr><td>Consumer</td><td>&lt;入参类型&gt;，apply方法的出参为void</td><td>程序中的消费型逻辑的抽象</td><td>就比如Collection体系forEach方法，将每一个元素取出，交给Consumer指定的消费逻辑进行消费</td></tr><tr><td>Suppiler</td><td>&lt;出参类型&gt;，get方法的入参为void</td><td>程序中的生产逻辑的抽象</td><td>就比如最常用的，new对象，这就是一个很经典的生产者逻辑，至于new什么，怎么new，这就是Suppiler中具体逻辑的写法了</td></tr></tbody></table><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MappingExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> show(<span class="string">&quot;abcd&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> show(<span class="string">&quot;abcd&quot;</span>, s -&gt; s.length() + <span class="number">3</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;第1个返回值：%d，第2个返回值：%d&quot;</span>, i1, i2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以在调用方法时传入个性化的映射逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">show</span><span class="params">(String s, Function&lt;String, Integer&gt; function)</span> &#123;</span><br><span class="line">        <span class="comment">//当传入的方法映射为null时，调用默认逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(function)) &#123;</span><br><span class="line">            <span class="keyword">return</span> s.length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> function.apply(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，在 java.util.function 包在上面的基本接口外进行了拓展</p><table><thead><tr><th>扩展模式</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td>泛型参数具体化</td><td>相当于具体化了四大函数式接口的泛型，让他们更具体的对于某一种情况进行操作。比如泛型被规定为int long double等等</td><td>IntToDoubleFunction</td></tr><tr><td>泛型类型多元化</td><td>相当于提供了二元操作，比如二元Consumer，就是消费两个参数，二元Function，就是两个入参对应一个出参这种</td><td><code>BiConsumer</code>二元消费者、<code>BiFunction</code> 二元函数</td></tr><tr><td>泛型参数统一化</td><td>统一，XXXXOperator接口，【主要是Function扩展体系】，出参和入参的类型，强行让他们的类型固定为同一类型</td><td><code>UnaryOperator</code>一元运算符、<code>DoubleBinaryOperator</code>小数型二元运算符</td></tr></tbody></table><p>还有很多<strong>泛型参数具体化</strong>后的各种Consumer和Supplier，以及像 <code>IntToDoubleFunction</code> 之类的拓展；还有<strong>泛型参数多元化</strong>如<code>BiConsumer</code>二元消费者、<code>BiFunction</code> 二元函数；以及<strong>泛型参数统一化</strong>的XXXXOperator接口，如等</p><p>参考资料：</p><p><a href="https://zhuanlan.zhihu.com/p/531651771">JDK8新特性第二篇：四大函数式接口【Function/Consumer/Supplier/Perdicate】、接口的扩展方法【default/static】 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/H_X_P_/article/details/105030682">Java函数式接口的一个疑惑：为什么Comparator接口有两个抽象方法compare和equals，Comparator还是一个函数式接口？（@FunctionalInterface）-CSDN博客</a></p><h2 id="方法引用">方法引用</h2><p>Lambda表达式将函数简化为入参、方法体、返回值，当这些条件和外部方法匹配时，可以简化为 <code>XXX::XX</code> 的格式</p><table><thead><tr><th>Lambda</th><th>等效的方法引用</th></tr></thead><tbody><tr><td>(Apple a) -&gt; a.getWeight()</td><td>Apple::getWeight</td></tr><tr><td>() -&gt; Thread.currentThread().dumpStack()</td><td>Thread.currentThread()::dumpStack</td></tr><tr><td>(str, i) -&gt; str.substring(i)</td><td>String::substring</td></tr><tr><td>(String s) -&gt; System.out.println(s)</td><td>System.out::println</td></tr></tbody></table><h3 id="静态方法引用">静态方法引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统方式：匿名内部类</span></span><br><span class="line">Comparator&lt;Integer&gt; c1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1 - o2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用Lambda表达式，重写上面的方法</span></span><br><span class="line">Comparator&lt;Integer&gt; c2 = (i, j) -&gt; (i - j);</span><br><span class="line"><span class="comment">//使用Lambda表达式，重写的是ToIntFunction的applyAsInt方法</span></span><br><span class="line">Comparator&lt;Integer&gt; c3 = Comparator.comparingInt(i -&gt; i);</span><br><span class="line"><span class="comment">//静态方法引用</span></span><br><span class="line">Comparator&lt;Integer&gt; c4 = Integer::compare;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="构造器引用">构造器引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//功能要求：新建实例对象</span></span><br><span class="line">    <span class="comment">//使用Lambda表达式</span></span><br><span class="line">    Supplier&lt;User&gt; s1 = () -&gt; <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="comment">//使用构造器引用</span></span><br><span class="line">    Supplier&lt;User&gt; s2 = User::<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//功能要求：把一个Set集合转化为List集合</span></span><br><span class="line">    <span class="comment">//使用Lambda表达式</span></span><br><span class="line">    Function&lt;Set, List&gt; f1 = set -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>(set);</span><br><span class="line">    <span class="comment">//使用构造器引用</span></span><br><span class="line">    Function&lt;Set, List&gt; f2 = ArrayList::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure><h3 id="实例对象引用">实例对象引用</h3><p>案例1：字符串分隔并输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc,def,ghi,jkl&quot;</span>;</span><br><span class="line"><span class="comment">//调用实例对象的方法，有Lambda表达式和方法引用两种形式</span></span><br><span class="line">Function&lt;String, String[]&gt; func1 = str -&gt; s.split(str);</span><br><span class="line">Function&lt;String, String[]&gt; func2 = s::split;</span><br><span class="line"><span class="comment">//输出按&quot;,&quot;分隔的字符串数组</span></span><br><span class="line">Arrays.asList(func2.apply(<span class="string">&quot;,&quot;</span>)).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>案例2：验证数字是否大于某个值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//如果不新增方法，也可以用Lambda表达式的 i -&gt; i &gt;50</span></span><br><span class="line">    Predicate&lt;Integer&gt; p = <span class="built_in">this</span>::testInteger;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">testInteger</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> integer &gt; <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非静态方法引用">非静态方法引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.BiConsumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//无参方法，相当于 user -&gt; user.getUserName();</span></span><br><span class="line">        Function&lt;User, String&gt; f1 = User::getUserName;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//带参方法，相当于 (user, str) -&gt; user.setUserName(str);</span></span><br><span class="line">        BiConsumer&lt;User, String&gt; f2 = User::setUserName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结</p><table><thead><tr><th>类型</th><th>格式</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td>静态方法引用</td><td>类名::方法名</td><td>方法体直接引用另外一个类的静态方法</td><td>(args) -&gt;  ClassName.staticMethod(agrs)的Lambda，转化为ClassName::staticMethod</td></tr><tr><td>构造器引用</td><td>类名::new</td><td>通过构造器创建实例对象</td><td>(args) -&gt; new ClassName(agrs)  可以被简化为 ClassName::new</td></tr><tr><td>实例对象方法引用</td><td>实例对象名::方法名</td><td>调用内存中实例对象所在类的方法</td><td>(args) -&gt;<a href="http://object.XXX">object.XXX</a>(args)  可以被简写为：object::XXX【备注：object是一个程序中定义的对象即可，XXX就是该Object的方法】</td></tr><tr><td>非静态方法的引用</td><td>类名::方法名</td><td>调用内存中实例对象所在类的方法</td><td>有参的(实例名, args) -&gt; 实例名.XXXXX(agrs) ，无参的 () -&gt;实例名.可以被简化为 实例所在类名::XXXXX</td></tr></tbody></table><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/534238509">JDK8新特性第三篇：方法引用 + StreamAPI - 知乎 (zhihu.com)</a></p><h2 id="复合-Lambda-表达式">复合 Lambda 表达式</h2><h3 id="比较器复合">比较器复合</h3><p>Comparator具有一个叫作comparing的静态辅助方法，它可以接受一个Function来提取Comparable键值，并生成一个Comparator对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort(comparing(Apple::getWeight)<span class="comment">//按重量比较</span></span><br><span class="line">    .reversed()  <span class="comment">// 递减排序</span></span><br><span class="line">    .thenComparing(Apple::getCountry)); <span class="comment">// 两个苹果一样重时按照国家排序</span></span><br></pre></td></tr></table></figure><h3 id="谓词复合">谓词复合</h3><p>谓词接口包括三个方法： negate、 and和or，让你可以重用已有的Predicate来创建更复杂的谓词。比如，可以使用negate方法来返回一个Predicate的非，比如苹果不是红的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Apple&gt; notRedApple = redApple.negate(); <span class="comment">// 产生现有Predicate对象redApple的非</span></span><br></pre></td></tr></table></figure><p>and和or方法是按照在表达式链中的位置，从左向右确定优先级的。因此， a.or(b).and©可以看作(a || b) &amp;&amp; c</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链接Predicate的方法来构造更复杂Predicate对象</span></span><br><span class="line">Predicate&lt;Apple&gt; redAndHeavyAppleOrGreen = redApple.and(a -&gt; a.getWeight() &gt; <span class="number">150</span>).or(a -&gt; <span class="string">&quot;green&quot;</span>.equals(a.getColor()));</span><br></pre></td></tr></table></figure><h3 id="函数复合">函数复合</h3><p>可以把Function接口所代表的Lambda表达式复合起来。 Function接口为此配了andThen和compose两个默认方法，它们都会返回Function的一个实例。</p><p>andThen方法会返回一个函数，它先对输入应用一个给定函数，再对输出应用另一个函数。比如，假设有一个函数f给数字加1 (x -&gt; x + 1)，另一个函数g给数字乘2，你可以将它们组合成一个函数h，先给数字加1，再给结果乘2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; f = x -&gt; x + <span class="number">1</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; g = x -&gt; x * <span class="number">2</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; h = f.andThen(g);</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> h.apply(<span class="number">1</span>); <span class="comment">// 结果是4</span></span><br></pre></td></tr></table></figure><p>compose方法，先把给定的函数用作compose的参数里面给的那个函数，然后再把函数本身用于结果。比如在上一个例子里用compose的话，它将意味着f(g(x))，而andThen则意味着g(f(x))：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; f = x -&gt; x + <span class="number">1</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; g = x -&gt; x * <span class="number">2</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; h = f.compose(g);</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> h.apply(<span class="number">1</span>); <span class="comment">// 结果是3</span></span><br></pre></td></tr></table></figure><p>参考资料：<a href="https://blog.csdn.net/qmqm011/article/details/82427570">【Java 8】Lambda表达式-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">Java8引入的函数式编程语法，不应再被当做新特性来排斥</summary>
    
    
    
    <category term="Coding" scheme="https://92rw.github.io/categories/Coding/"/>
    
    
    <category term="编程" scheme="https://92rw.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记</title>
    <link href="https://92rw.github.io/posts/3c79af21.html"/>
    <id>https://92rw.github.io/posts/3c79af21.html</id>
    <published>2023-11-02T08:00:00.000Z</published>
    <updated>2023-11-05T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="掌握数据结构和算法逻辑">掌握数据结构和算法逻辑</h2><p>很多时候感觉到自己的思路不够清晰，在刷题时看到其他人的题解才发现自己的不足</p><ol><li><a href="https://leetcode.com/problems/two-sum/solutions/3619262/3-method-s-c-java-python-beginner-friendly/">Two Sum 二和</a></li><li><a href="https://leetcode.com/problems/roman-to-integer/solutions/3651672/best-method-c-java-python-beginner-friendly/">Roman to Integer 罗马到整数</a></li><li><a href="https://leetcode.com/problems/palindrome-number/solutions/3651712/2-method-s-c-java-python-beginner-friendly/">Palindrome Number 回文数</a></li><li><a href="https://leetcode.com/problems/maximum-subarray/solutions/3666304/beats-100-c-java-python-beginner-friendly/">Maximum Subarray 最大子阵列</a></li><li><a href="https://leetcode.com/problems/remove-element/solutions/3670940/best-100-c-java-python-beginner-friendly/">Remove Element 删除元素</a></li><li><a href="https://leetcode.com/problems/contains-duplicate/solutions/3672475/4-method-s-c-java-python-beginner-friendly/">Contains Duplicate 包含重复项</a></li><li><a href="https://leetcode.com/problems/add-two-numbers/solutions/3675747/beats-100-c-java-python-beginner-friendly/">Add Two Numbers 将两个数字相加</a></li><li><a href="https://leetcode.com/problems/majority-element/solutions/3676530/3-methods-beats-100-c-java-python-beginner-friendly/">Majority Element 多数元素</a></li><li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3676877/best-method-100-c-java-python-beginner-friendly/">Remove Duplicates from Sorted Array<br>从排序数组中删除重复项</a></li></ol><p>在while循环和if判断条件搭配使用时，需要清楚地认识到：if语句如果没有改变循环判断条件中的值，那么在if执行结束后，循环会在之前的位置上重新循环，而不会像for循环那样跳到下一处</p><p>栈的Java实现：<a href="https://blog.csdn.net/cartoon_/article/details/87992743">Stack，ArrayDeque，LinkedList的区别_stack,arraydeque,linkedlist 的区别-CSDN博客</a></p><h2 id="复杂度比较">复杂度比较</h2><p>复杂度比较公式： $O(1)&lt;O(\log n)&lt;O(\sqrt{n})&lt;O(n)&lt;O(n\log n)&lt;O(n^2)&lt;O(2^n)&lt;O(n!)$</p><ul><li>在常数时间下，访问速度：位运算&gt;算术运算&gt;寻址&gt;Hash函数</li><li>链表属于跳转结构，消耗的不是常数时间</li></ul><h3 id="复杂度和控制结构的写法无关">复杂度和控制结构的写法无关</h3><p>只有一个循环，可以实现 <code>O(n²)</code> 的时间复杂度，例如while循环实现的冒泡排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> n - <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (end &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">               arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">               arr[i + <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; end - <span class="number">1</span>) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">end--;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个for循环，通过不同的循环条件，可以实现<code>O(log(n))</code> 和 <code>O(n²)</code>  两种时间复杂度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">200000</span>;</span><br><span class="line"><span class="type">long</span> start;</span><br><span class="line"><span class="type">long</span> end;</span><br><span class="line">System.out.println(<span class="string">&quot;测试开始&quot;</span>);</span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt;= N; j += i) &#123;</span><br><span class="line"><span class="comment">// 这两个嵌套for循环的流程，时间复杂度为O(N * logN)</span></span><br><span class="line"><span class="comment">// 1/1 + 1/2 + 1/3 + 1/4 + 1/5 + ... + 1/n，也叫&quot;调和级数&quot;，收敛于O(logN)</span></span><br><span class="line"><span class="comment">// 所以如果一个流程的表达式 : n/1 + n/2 + n/3 + ... + n/n</span></span><br><span class="line"><span class="comment">// 那么这个流程时间复杂度O(N * logN)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;测试结束，运行时间 : &quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;测试开始&quot;</span>);</span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt;= N; j++) &#123;</span><br><span class="line"><span class="comment">// 这两个嵌套for循环的流程，时间复杂度为O(N^2)</span></span><br><span class="line"><span class="comment">// 很明显等差数列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;测试结束，运行时间 : &quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="平均时间复杂度">平均时间复杂度</h3><p>严格固定流程的算法，一定强调最差情况（比如插入排序）；算法流程上利用随机行为作为重要部分的，要看平均或者期望的时间复杂度，因为最差的时间复杂度无意义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机生成长度为n</span></span><br><span class="line"><span class="comment">// 值在0~v-1之间</span></span><br><span class="line"><span class="comment">// 且任意相邻两数不相等的数组</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">arr1[<span class="number">0</span>] = (<span class="type">int</span>) (Math.random() * v);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">arr1[i] = (<span class="type">int</span>) (Math.random() * v);</span><br><span class="line">&#125; <span class="keyword">while</span> (arr1[i] == arr1[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : arr1) &#123;</span><br><span class="line">System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;=========&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面的算法最差时间复杂度是正无穷，但是在大数据下没有意义，在计算时考虑的是平均复杂度</p><p>各个语言中的动态数组的初始大小和实际扩容因子可能会变化，但是均摊都是<code>O(1)</code>，例如Java中的动态数组ArrayList</p><h3 id="不同数据结构、排序算法对应的时间、空间复杂度">不同数据结构、排序算法对应的时间、空间复杂度</h3><p><img src="https://www.bigocheatsheet.com/img/big-o-cheat-sheet-poster.png" alt="数据结构、算法复杂度对比图"></p><p>常用的数据结构时间、空间复杂度</p><table><thead><tr><th>Data  Structure</th><th>Time Complexity</th><th>时间复杂度</th><th>Time Complexity</th><th>时间复杂度</th><th>Time Complexity</th><th>时间复杂度</th><th>Time Complexity</th><th>时间复杂度</th><th>Space Complexity</th></tr></thead><tbody><tr><td></td><td>Average</td><td>平均</td><td>Average</td><td>平均</td><td>Worst</td><td>最差</td><td>Worst</td><td>最差</td><td>Worst最差</td></tr><tr><td></td><td>Access 访问</td><td>Search 查找</td><td>Insertion 插入</td><td>Deletion 删除</td><td>Access 访问</td><td>Search 查找</td><td>Insertion 插入</td><td>Deletion 删除</td><td></td></tr><tr><td>数组 <a href="http://en.wikipedia.org/wiki/Array_data_structure">Array</a></td><td>Θ(1)</td><td>Θ(n)</td><td>Θ(n)</td><td>Θ(n)</td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>栈 <a href="http://en.wikipedia.org/wiki/Stack_(abstract_data_type)">Stack</a></td><td>Θ(n)</td><td>Θ(n)</td><td>Θ(1)</td><td>Θ(1)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>O(n)</td></tr><tr><td>队列 <a href="http://en.wikipedia.org/wiki/Queue_(abstract_data_type)">Queue</a></td><td>Θ(n)</td><td>Θ(n)</td><td>Θ(1)</td><td>Θ(1)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>O(n)</td></tr><tr><td>单向链表 <a href="http://en.wikipedia.org/wiki/Singly_linked_list#Singly_linked_lists">Singly-Linked List</a></td><td>Θ(n)</td><td>Θ(n)</td><td>Θ(1)</td><td>Θ(1)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>O(n)</td></tr><tr><td>双向链表 <a href="http://en.wikipedia.org/wiki/Doubly_linked_list">Doubly-Linked List</a></td><td>Θ(n)</td><td>Θ(n)</td><td>Θ(1)</td><td>Θ(1)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>O(n)</td></tr><tr><td>跳表 <a href="http://en.wikipedia.org/wiki/Skip_list">Skip List</a></td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n log(n))</td></tr><tr><td>哈希表 <a href="http://en.wikipedia.org/wiki/Hash_table">Hash Table</a></td><td>N/A</td><td>Θ(1)</td><td>Θ(1)</td><td>Θ(1)</td><td>N/A</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>二叉搜索树 <a href="http://en.wikipedia.org/wiki/Binary_search_tree">Binary Search Tree</a></td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>笛卡尔树 <a href="https://en.wikipedia.org/wiki/Cartesian_tree">Cartesian Tree</a></td><td>N/A</td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>N/A</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>B树 <a href="http://en.wikipedia.org/wiki/B_tree">B-Tree</a></td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>O(log(n))</td><td>O(log(n))</td><td>O(log(n))</td><td>O(log(n))</td><td>O(n)</td></tr><tr><td>红黑树 <a href="http://en.wikipedia.org/wiki/Red-black_tree">Red-Black Tree</a></td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>O(log(n))</td><td>O(log(n))</td><td>O(log(n))</td><td>O(log(n))</td><td>O(n)</td></tr><tr><td>伸展树 <a href="https://en.wikipedia.org/wiki/Splay_tree">Splay Tree</a></td><td>N/A</td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>N/A</td><td>O(log(n))</td><td>O(log(n))</td><td>O(log(n))</td><td>O(n)</td></tr><tr><td>AVL树 <a href="http://en.wikipedia.org/wiki/AVL_tree">AVL Tree</a></td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>O(log(n))</td><td>O(log(n))</td><td>O(log(n))</td><td>O(log(n))</td><td>O(n)</td></tr><tr><td>K-D树 <a href="http://en.wikipedia.org/wiki/K-d_tree">KD Tree</a></td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>Θ(log(n))</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr></tbody></table><p>常用的排序算法时间、空间复杂度</p><table><thead><tr><th style="text-align:left">Algorithm</th><th style="text-align:left">Time Complexity</th><th style="text-align:left">Time Complexity</th><th style="text-align:left">Time Complexity</th><th style="text-align:left">Space Complexity</th></tr></thead><tbody><tr><td style="text-align:left"></td><td style="text-align:left">Best</td><td style="text-align:left">Average</td><td style="text-align:left">Worst</td><td style="text-align:left">Worst</td></tr><tr><td style="text-align:left">快速排序 <a href="http://en.wikipedia.org/wiki/Quicksort">Quicksort</a></td><td style="text-align:left"><code>Ω(n log(n))</code></td><td style="text-align:left"><code>Θ(n log(n))</code></td><td style="text-align:left"><code>O(n^2)</code></td><td style="text-align:left"><code>O(log(n))</code></td></tr><tr><td style="text-align:left">归并排序 <a href="http://en.wikipedia.org/wiki/Merge_sort">Mergesort</a></td><td style="text-align:left"><code>Ω(n log(n))</code></td><td style="text-align:left"><code>Θ(n log(n))</code></td><td style="text-align:left"><code>O(n log(n))</code></td><td style="text-align:left"><code>O(n)</code></td></tr><tr><td style="text-align:left"><a href="http://en.wikipedia.org/wiki/Timsort">Timsort</a></td><td style="text-align:left"><code>Ω(n)</code></td><td style="text-align:left"><code>Θ(n log(n))</code></td><td style="text-align:left"><code>O(n log(n))</code></td><td style="text-align:left"><code>O(n)</code></td></tr><tr><td style="text-align:left">堆排序 <a href="http://en.wikipedia.org/wiki/Heapsort">Heapsort</a></td><td style="text-align:left"><code>Ω(n log(n))</code></td><td style="text-align:left"><code>Θ(n log(n))</code></td><td style="text-align:left"><code>O(n log(n))</code></td><td style="text-align:left"><code>O(1)</code></td></tr><tr><td style="text-align:left">冒泡排序 <a href="http://en.wikipedia.org/wiki/Bubble_sort">Bubble Sort</a></td><td style="text-align:left"><code>Ω(n)</code></td><td style="text-align:left"><code>Θ(n^2)</code></td><td style="text-align:left"><code>O(n^2)</code></td><td style="text-align:left"><code>O(1)</code></td></tr><tr><td style="text-align:left">插入排序 <a href="http://en.wikipedia.org/wiki/Insertion_sort">Insertion Sort</a></td><td style="text-align:left"><code>Ω(n)</code></td><td style="text-align:left"><code>Θ(n^2)</code></td><td style="text-align:left"><code>O(n^2)</code></td><td style="text-align:left"><code>O(1)</code></td></tr><tr><td style="text-align:left">选择排序 <a href="http://en.wikipedia.org/wiki/Selection_sort">Selection Sort</a></td><td style="text-align:left"><code>Ω(n^2)</code></td><td style="text-align:left"><code>Θ(n^2)</code></td><td style="text-align:left"><code>O(n^2)</code></td><td style="text-align:left"><code>O(1)</code></td></tr><tr><td style="text-align:left">树形排序 <a href="https://en.wikipedia.org/wiki/Tree_sort">Tree Sort</a></td><td style="text-align:left"><code>Ω(n log(n))</code></td><td style="text-align:left"><code>Θ(n log(n))</code></td><td style="text-align:left"><code>O(n^2)</code></td><td style="text-align:left"><code>O(n)</code></td></tr><tr><td style="text-align:left">希尔排序 <a href="http://en.wikipedia.org/wiki/Shellsort">Shell Sort</a></td><td style="text-align:left"><code>Ω(n log(n))</code></td><td style="text-align:left"><code>Θ(n(log(n))^2)</code></td><td style="text-align:left"><code>O(n(log(n))^2)</code></td><td style="text-align:left"><code>O(1)</code></td></tr><tr><td style="text-align:left">桶排序 <a href="http://en.wikipedia.org/wiki/Bucket_sort">Bucket Sort</a></td><td style="text-align:left"><code>Ω(n+k)</code></td><td style="text-align:left"><code>Θ(n+k)</code></td><td style="text-align:left"><code>O(n^2)</code></td><td style="text-align:left"><code>O(n)</code></td></tr><tr><td style="text-align:left">基数排序 <a href="http://en.wikipedia.org/wiki/Radix_sort">Radix Sort</a></td><td style="text-align:left"><code>Ω(nk)</code></td><td style="text-align:left"><code>Θ(nk)</code></td><td style="text-align:left"><code>O(nk)</code></td><td style="text-align:left"><code>O(n+k)</code></td></tr><tr><td style="text-align:left">计数排序 <a href="https://en.wikipedia.org/wiki/Counting_sort">Counting Sort</a></td><td style="text-align:left"><code>Ω(n+k)</code></td><td style="text-align:left"><code>Θ(n+k)</code></td><td style="text-align:left"><code>O(n+k)</code></td><td style="text-align:left"><code>O(k)</code></td></tr><tr><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Cubesort">Cubesort</a></td><td style="text-align:left"><code>Ω(n)</code></td><td style="text-align:left"><code>Θ(n log(n))</code></td><td style="text-align:left"><code>O(n log(n))</code></td><td style="text-align:left"><code>O(n)</code></td></tr></tbody></table><p>查找算法的复杂度：<a href="https://www.hello-algo.com/chapter_searching/searching_algorithm_revisited/#1052">10.5  重识搜索算法 - Hello 算法 (hello-algo.com)</a></p><h2 id="其他人的刷题经验分享">其他人的刷题经验分享</h2><p><a href="https://labuladong.github.io/algo/di-ling-zh-bfe1b/xue-xi-sua-01220/">学习算法和刷题的框架思维 | labuladong 的算法笔记</a></p><p><a href="https://programmercarl.com/">代码随想录 (programmercarl.com)</a></p><p><a href="https://www.acoier.com/">宫水三叶的刷题日记 (acoier.com)</a></p>]]></content>
    
    
    <summary type="html">基础不牢，地动山摇</summary>
    
    
    
    <category term="Algorithm" scheme="https://92rw.github.io/categories/Algorithm/"/>
    
    
    <category term="算法" scheme="https://92rw.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>程序员节的个人记录</title>
    <link href="https://92rw.github.io/posts/e27a1b5f.html"/>
    <id>https://92rw.github.io/posts/e27a1b5f.html</id>
    <published>2023-10-24T08:00:00.000Z</published>
    <updated>2023-10-24T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="程序员节">程序员节</h2><p><strong>程序员节</strong>（英语：Programmer’s Day）在俄罗斯定为每年的第256天（256 = 2的8次方 ），在中国常常被定义在10月24日（1024 = 2 的10次方，也是存储单位换算时的比例）</p><ul><li><p>给自己一点鼓励</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="comment">[~!+<span class="comment">[]</span>+&#123;&#125;]</span><span class="comment">[~+<span class="comment">[]</span>]</span>+&#123;&#125;)<span class="comment">[!+<span class="comment">[]</span>*!+<span class="comment">[]</span>]</span>+(&#123;&#125;+<span class="comment">[]</span>)<span class="comment">[<span class="comment">[~!+<span class="comment">[]</span>]</span>*~+<span class="comment">[]</span>]</span></span><br></pre></td></tr></table></figure><p>打开浏览器，按下 F12，在 console 中输入上面代码回车，嗯… 果然 NB！</p></li><li><p>网页编辑器</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">document.body.contentEditable</span>=<span class="string">&#x27;true&#x27;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>打开浏览器，按下 F12，在 console 中输入上面代码回车，然后你就可以像编辑 word 一样编辑网页。</p></li><li><p>用python画个❤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&quot;print(&#x27;\n&#x27;.join([&#x27;&#x27;.join([(&#x27;1024&#x27;[(x-y) % len(&#x27;1024&#x27;)] if str(((x*0.05)**2+(y*0.1)**2-1)**3-(x*0.05)**2*(y*0.1)**3-0.00001).startswith(&#x27;-&#x27;) else &#x27; &#x27;) for x in range(-30, 30)]) for y in range(15, -15, -1)]))&quot;</span></span><br></pre></td></tr></table></figure><p>任何有 python 环境的地方（例如cmd）执行上面的代码，可以看到用字符画组成的心形</p></li></ul><h2 id="编程语言的学习">编程语言的学习</h2><p>从2023年6月决定转码，到现在已经完成的学习内容：</p><p>Java语言：Java SE，JavaWeb，JDBC，SpringBoot，JavaFX</p><p>数据库：MySQL语法、Druid连接池、MyBatis-Plus</p><p>前端页面：HTML和JavaScript语法、Vue使用</p><h2 id="博客改版记录">博客改版记录</h2><p>托管在Github上的网站，既可以用来展示自己写的学习心得，也可以提供对外展示的窗口。最初为了节省建站折腾的时间，使用 Gridea 平台编写文章后发布，最初只是发布一些工作中的软件使用总结，方便自己在后续使用时查找。2021年底因为换了一台工作用的电脑，而新电脑上Gridea无法正常连接到个人网站的项目，我当时又没有足够的时间精力完成网站重新部署，因此网站有一年多的时间不再更新。</p><p>在决定转码之后，觉得自己有必要完善一下个人页面，因此随着Java语言的学习进入到JavaWeb阶段，开始接触HTML和JavaScript语法时，我开始在网上浏览其他人的主页，<a href="https://blog.zhheo.com/p/30c885b3.html">我应该怎么设计我的博客？如何搭建一个体验好的博客？ | 张洪Heo (zhheo.com)</a> 对我的触动很大。我最终决定使用 <a href="https://github.com/fomalhaut1998/hexo-theme-Fomalhaut">Fomalhaut开源模板</a> 重新搭建网站，最终在2023年10月2日上线新页面。为了避免再次出现无法将变动上传到项目main分支的问题，我在本地调试完成后，先将源代码上传到Github私有仓库，由系统自动调用Github Action实现网站更新。</p><h3 id="个性化变动">个性化变动</h3><ul><li><p>背景图片：从我的个人微博下载了带水印的照片，再经过一次压缩即可作为网页背景使用。默认黑夜背景是在泰国拍摄的蒸汽旅游列车；默认白天背景在桌面端是上海莘庄拍摄的国铁普速和轨交5号线列车同框，在手机端是上海恒丰路天桥拍摄的沪宁城际、京沪铁路、轨交三四号线列车同框。在可供替换的背景图中，也有一些我拍摄的好图。</p></li><li><p>随页面进度滚动的船锚：根据唐志远博客的文章 <a href="https://fe32.top/articles/hexo1613/">请收下这只可爱的猫咪吧</a> 布置，感觉在船锚外边框如果加一个轮廓会和背景配合更好，但感觉对页面整体效果影响不大，因此暂时维持现状。</p></li><li><p>Github贡献图：在我的Github首页使用了 <a href="https://github.com/Platane/snk">Platane/snk</a> 代码实现贪吃蛇效果，在个人网站的“关于”页面引入 <a href="https://akilar.top/posts/1f9c68c9/">hexo-github-calendar</a> 项目的技术。</p></li><li><p>文章统计表格：参考 <a href="https://blog.eurkon.com/post/1213ef82.html">Hexo 博客文章统计图 | Eurkon</a> 布置，在上线过程中也出过无法显示的问题，感谢作者提供的解答。</p></li></ul><h3 id="引入的功能">引入的功能</h3><ul><li>利用不蒜子API实现的访问次数统计</li><li>参考文章 <a href="https://fe32.top/articles/hexo1611/">基于 Hexo 键入评论功能</a> 利用MongoDB数据库实现的Twikoo评论功能</li></ul><h3 id="解决的bug">解决的bug</h3><ol><li><p>由于博客的IP地理坐标API，对于来自其他地区的请求存在限制，在我上线后测试时，公告栏的欢迎窗口时常不能正常显示，在控制台输出<code>Uncaught ReferenceError: ipLoacation is not defined at showWelcome (fomal.js:100:61)</code>。</p><ul><li>为了支持其他地区的访问请求，切换了ip地理信息请求的API源。但由于浏览器访问https网站时，会拦截向http协议发出的请求，导致本地在 localhost 环境下虽然能正常显示，部署后却无法正常加载。</li><li>最终解决：利用Vercel反向代理，获取访问数据源的IP后，向API源发出请求，将返回结果打包封装后转给前端页面。</li></ul></li><li><p>文章页面显示为空白：在Github Action的使用教程中，建议将网站上线的版本和本地版本保持一致，避免出现布局错误。</p><ul><li>本地部署的node版本是v18.18.0，一开始将 Node.js 也配置为最新版，结果造成博客中的文章加载时都是空白。</li><li>后续将配置文件中的 Node.js 版本设置为v14，又出现了 <code>error workbox-build@6.6.1: The engine &quot;node&quot; is incompatible with this module. Expected version &quot;&gt;=16.0.0&quot;. Got &quot;14.21.3&quot;</code> 的错误。</li><li>最终解决：将 Node.js 版本设为 v16，避免版本太低或太高</li></ul></li></ol><h3 id="尝试后失败">尝试后失败</h3><ul><li>i18n国际化，尝试安装 <a href="https://github.com/Jamling/hexo-generator-i18n">hexo-generator-i18n</a> 实现英文界面的切换，但是菜单栏没法按设想的随语言变化</li><li>将不同的Vercel项目集中在一起：尝试将Github Calendar 和地理信息API放在一个项目下共同管理。实际调试中频频报错，最终未能成功</li></ul>]]></content>
    
    
    <summary type="html">写给 2023.10.24 的自己</summary>
    
    
    
    <category term="Blog" scheme="https://92rw.github.io/categories/Blog/"/>
    
    
    <category term="个人网站" scheme="https://92rw.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>地理坐标和球面距离</title>
    <link href="https://92rw.github.io/posts/da0c2a7e.html"/>
    <id>https://92rw.github.io/posts/da0c2a7e.html</id>
    <published>2023-10-15T08:00:00.000Z</published>
    <updated>2023-10-15T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大圆公式">大圆公式</h2><p>在地球表面上，大圆航线是两点之间最短距离的路径，它总是沿着穿过地球中心的一个大圆弧。Haversine公式是一种用于计算两个球面上两点之间最短弧长（也就是大圆距离）的方法，能够确保计算的是沿着地球表面的最短路径。在航空和导航领域，它经常用于计算飞行路径上两个地点之间的最短距离，这就是所谓的大圆航线。</p><p>Haversine公式的一般形式如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> = sin²(Δlat/<span class="number">2</span>) + <span class="built_in">cos</span>(lat1) * <span class="built_in">cos</span>(lat2) * sin²(Δlon/<span class="number">2</span>)</span><br><span class="line">c = <span class="number">2</span> * <span class="built_in">atan2</span>(√a, √(<span class="number">1</span>-a))</span><br><span class="line">d = <span class="attribute">R</span> * c</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>Δlat和Δlon分别是两个点的纬度和经度差异。</li><li>lat1和lat2分别是两个点的纬度。</li><li>R是地球的半径，通常使用平均半径，约为6371千米（或3959英里）。</li><li>d是两点之间的大圆距离。</li></ul><p>通过Haversine公式，你可以计算两个地点之间的大圆距离，这对于飞行路径规划和导航非常有用。注意，这个公式基于球面几何，忽略了地球的不规则性，但在大多数情况下提供了足够的准确性。如果需要更高精度的计算，还可以使用更复杂的椭球模型或地理信息系统（GIS）工具。</p><p><img src="https://static-resources.vercel.app/image/cover/Phanak_Island.jpg" alt="泰国Phanak岛乘船拍摄的风景"></p><h3 id="代码实现">代码实现</h3><p>网站公告栏的“欢迎信息”中，通过IP获取到访问者的地理位置（经纬度、国家、城市），在后台通过一个函数计算出和站长的距离，显示在页面上（感谢 Fomalhaut🥝 提供的 <a href="https://www.fomal.cc/posts/d739261b.html">魔改教程</a> 和 <a href="https://api.kxyr.top/#api-IP_API-GetApiIp">vercel-thinkjs (kxyr.top)</a> 提供的API）</p><p>在目前上线版本fomal.js文件中，配置的公式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getDistance</span>(<span class="params">e1, n1, e2, n2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> R = <span class="number">6371</span></span><br><span class="line">    <span class="keyword">const</span> &#123;sin, cos, asin, <span class="variable constant_">PI</span>, hypot&#125; = <span class="title class_">Math</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">getPoint</span> = (<span class="params">e, n</span>) =&gt; &#123;</span><br><span class="line">        e *= <span class="variable constant_">PI</span> / <span class="number">180</span></span><br><span class="line">        n *= <span class="variable constant_">PI</span> / <span class="number">180</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">x</span>: <span class="title function_">cos</span>(n) * <span class="title function_">cos</span>(e), <span class="attr">y</span>: <span class="title function_">cos</span>(n) * <span class="title function_">sin</span>(e), <span class="attr">z</span>: <span class="title function_">sin</span>(n)&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> a = <span class="title function_">getPoint</span>(e1, n1)</span><br><span class="line">    <span class="keyword">let</span> b = <span class="title function_">getPoint</span>(e2, n2)</span><br><span class="line">    <span class="keyword">let</span> c = <span class="title function_">hypot</span>(a.<span class="property">x</span> - b.<span class="property">x</span>, a.<span class="property">y</span> - b.<span class="property">y</span>, a.<span class="property">z</span> - b.<span class="property">z</span>)</span><br><span class="line">    <span class="keyword">let</span> r = <span class="title function_">asin</span>(c / <span class="number">2</span>) * <span class="number">2</span> * R</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">round</span>(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>getDistance</code>函数计算两个地球表面上的点之间的距离，这两个点由它们的经度(<code>e</code>)和纬度(<code>n</code>)坐标指定。使用的公式是haversine公式，它提供两点之间的大圆距离，这是地球表面上的最短距离。</p><p>下面是代码的解释：</p><ul><li><code>R</code> 是地球的半径（以千米为单位）。</li><li><code>sin</code>, <code>cos</code>, <code>asin</code>, <code>PI</code>, <code>hypot</code> 是从 <code>Math</code> 对象中提取出来的，便于使用。</li><li>局部函数 <code>getPoint</code> 将经度和纬度从度转换为弧度，并计算地球表面上的3D笛卡尔坐标 <code>(x, y, z)</code>，因为<code>Math</code>库中的三角函数接受的参数单位是弧度。</li><li>使用<code>getPoint</code> 函数将两个坐标值转换成 <code>a</code> 和 <code>b</code> 是两个点的3D坐标，使用<code>hypot</code>函数计算3D空间中两个点之间的欧几里得距离 <code>c</code></li><li>使用<code>asin</code>函数将欧氏距离转换为大圆距离<code>r</code>，并将其与2倍的地球半径<code>R</code>相乘，得到haversine公式计算的球面距离 <code>r</code></li><li>使用<code>Math.round</code>方法将距离 <code>r</code> 四舍五入到最近的千米。</li></ul><p>虽然经度和纬度的值可以是负数（例如，南纬和西经的坐标），但是这个<code>getDistance</code>函数在计算两点之间的距离时不会返回负值。它使用的haversine公式和欧几里得距离都是基于两点之间的绝对距离计算的，结果总是非负的。</p><p>在这个函数中，经度和纬度被转换为弧度，并且用来计算两点在地球上的3D笛卡尔坐标。然后，使用<code>hypot</code>函数计算这两个点在3D空间中的直线距离。<code>hypot</code>函数计算的是两点之间的直线距离，是一个绝对值，所以不会是负数。</p><p>自2023年10月7日起，博客改为使用 <a href="http://IP-API.com">IP-API.com</a> 提供的API，其官方的 <a href="https://ip-api.com/docs/api:json">说明文档</a> 中，给出了该公式的另一种代码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getDistanceFromLatLonInKm</span>(<span class="params">lat1, lon1, lat2, lon2</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> R = <span class="number">6371</span>; <span class="comment">// Radius of the earth in km</span></span><br><span class="line"><span class="keyword">var</span> dLat = <span class="title function_">deg2rad</span>(lat2-lat1);  <span class="comment">// deg2rad below</span></span><br><span class="line"><span class="keyword">var</span> dLon = <span class="title function_">deg2rad</span>(lon2-lon1); </span><br><span class="line"><span class="keyword">var</span> a = </span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">sin</span>(dLat/<span class="number">2</span>) * <span class="title class_">Math</span>.<span class="title function_">sin</span>(dLat/<span class="number">2</span>) +</span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">cos</span>(<span class="title function_">deg2rad</span>(lat1)) * <span class="title class_">Math</span>.<span class="title function_">cos</span>(<span class="title function_">deg2rad</span>(lat2)) * </span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">sin</span>(dLon/<span class="number">2</span>) * <span class="title class_">Math</span>.<span class="title function_">sin</span>(dLon/<span class="number">2</span>); </span><br><span class="line"><span class="keyword">var</span> c = <span class="number">2</span> * <span class="title class_">Math</span>.<span class="title function_">atan2</span>(<span class="title class_">Math</span>.<span class="title function_">sqrt</span>(a), <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="number">1</span>-a)); </span><br><span class="line"><span class="keyword">var</span> d = R * c; <span class="comment">// Distance in km</span></span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deg2rad</span>(<span class="params">deg</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> deg * (<span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">180</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>getDistanceFromLatLonInKm</code> 函数也是计算两个地球表面上的点之间的距离（以千米为单位），和之前的函数类似，但是这个函数直接使用了 haversine 公式。以下是它的工作方式：</p><ul><li><code>R</code> 是地球的半径（以千米为单位）。</li><li><code>dLat</code> 和 <code>dLon</code> 分别是两个纬度和经度之间的差值，并且转换为弧度。</li><li><code>a</code> 是haversine公式的一部分，它使用三角函数来计算两点之间的圆上距离的平方。</li><li><code>c</code> 是两点之间的圆心角。</li><li><code>d</code> 是两点之间的实际距离，用千米为单位。</li><li><code>deg2rad</code> 函数，将度数转换为弧度。</li></ul><p>这个函数使用的各个数学运算（如 <code>Math.sin</code>, <code>Math.cos</code>, <code>Math.sqrt</code> 和 <code>Math.atan2</code>）都是针对距离和角度计算的，它们的结果或者是非负的（如平方根或三角函数的结果），或者是通过进一步的计算转化为非负的（如通过 <code>Math.atan2</code> 计算的 <code>c</code> 以及最终的 <code>d</code>）。</p><h2 id="现实生活中的航线">现实生活中的航线</h2><p>海上航行的航线选择取决于多种因素，包括但不限于距离、预计的航行时间、海洋和气象条件、潮流、风速风向、以及可能的危险区域等。这些因素可能影响船只是否选择直接沿大圆航线或其他路径航行。</p><h4 id="1-大圆航线">1. 大圆航线</h4><p>在理想的情况下，当仅考虑两点之间的最短距离时，船只通常会选择大圆航线作为航行路径，因为它代表了两点之间的最短物理距离。现代的航海导航系统，比如GPS和其他相关技术，可以实时计算并调整船只沿大圆航线的航行方向。然而，仅仅选择物理上的最短距离并不总是最高效或最安全的航线。</p><h4 id="2-沿着纬度航行">2. 沿着纬度航行</h4><p>在某些情况下，船只可能选择沿着一个特定纬度航行。这种方式在历史上比较常见，尤其是在尚未拥有现代导航技术的时代。沿着纬度线（也称为“平行线”）航行技术上更为简单，可以通过观察天体（如太阳和星星）来保持船只的航线。然而，除非目标地点刚好在同一纬度上，否则这种方法通常不是最短的航行路径。</p><p>实际上，在现代海上航行中，船舶的航线通常是基于多种因素、通过专业的航路规划软件和经验丰富的船长或导航员共同决策的结果。大圆航线或许提供一个理论上的最短路径，但船舶可能因应各种实际的海上条件和其他考虑进行适时的航线调整。</p><h3 id="3-六分仪">3. 六分仪</h3><p>六分仪是一个用于测量两个物体之间角度的仪器，通常用于测量星体（比如太阳或星星）相对于水平线的角度。在航海中，六分仪用于天文导航，帮助船只确定其经纬度，进而找到准确的地理位置。所以，六分仪不是仅用于沿纬度航行的工具，它是一个用于测量角度和确定位置的工具。</p><p>参考视频：<a href="https://www.bilibili.com/av317540318">航海定位的天才设计，六分仪的工作原理！</a></p><p>六分仪通常包括以下主要部分：</p><ol><li><strong>框架（Frame）</strong>：通常呈半圆形或四分之一圆形，上面标有度数刻度，度数范围通常是0到120度。</li><li><strong>主镜（Index Mirror）</strong>：这是一个小镜子，安装在一个可旋转的臂（指数臂）上。它用于反射观察者视线中的对象，如太阳或星星。</li><li><strong>人字臂（Index Arm）</strong>：这个臂长且可移动，用来调整主镜的角度。</li><li><strong>地平镜（Horizon Mirror）</strong>：另一个半透镜，反射水平线到观察者的视线中。</li><li><strong>望远镜（Telescope）</strong>：观察者通过望远镜看物体和反射在两个镜子上的影像。</li><li><strong>滤光片（Shades）</strong>：滤光片用于观测太阳，以防视线受损。</li></ol><p>基本使用步骤如下：</p><ol><li><strong>调整仪器</strong>：在使用六分仪之前，通常需要进行一些基本的校准，以确保准确的测量。这可能包括调整镜子的角度，确保六分仪的各部分清洁，以及设置滤光片等。</li><li><strong>测量角度</strong>：将望远镜对准一个天体（例如太阳或星星），然后移动指数臂，直到地平镜中的水平线映像和主镜中的天体映像对齐。在这个位置，你可以在六分仪的刻度上读取天体和地平线之间的角度。</li><li><strong>记录数据</strong>：记录下测量到的角度和测量的确切时间。使用这些数据和天文表，可以计算观察者的地理位置。</li><li><strong>确定位置</strong>：根据测得的角度和确切的时间（通常使用航海钟）来查找天文表（例如年度的《天文学年历》），确定观察者的精确位置。如果测量的是天体与水平线的角度，则这些数据通常用来计算纬度。若要计算经度，还需要知道观测时的格林尼治标准时间。</li></ol><p>在航海历史上，六分仪的使用方式通常如下：</p><ul><li>确定纬度：通过测量中天时太阳离水平线的角度，船长可以确定船只的纬度。因为当太阳达到其在天空中的最高点（即中天）时，它所在的纬度就是观测位置的纬度。</li><li>确定经度：需要知道格林尼治的准确时间，通过比较格林尼治时间和本地时间，船长可以计算出与格林尼治的经度差。这个计算在引入精确的航海钟后变得更加准确和可行。</li></ul><p>六分仪在现代已经不是航海定位的主要工具，因为全球定位系统（GPS）提供了一个更快捷、准确的定位方法。然而，六分仪仍然作为备用工具在某些情况下（例如GPS系统失效时）被使用，并且它在航海教育和培训中仍然占有一席之地，用于教育和训练船员传统的航海技能。</p><p>简而言之，船只的实际航线会基于多种因素来决定，并不总是简单的选择大圆航线或沿着某一纬度航行。现代航海已经能够利用各种高科技工具，包括卫星导航、海洋气象数据和计算机辅助航路规划系统，以优化航线、提高安全性和效率。</p>]]></content>
    
    
    <summary type="html">地球是圆的，而球面上最短的路径不是直线</summary>
    
    
    
    <category term="Algorithm" scheme="https://92rw.github.io/categories/Algorithm/"/>
    
    
    <category term="算法" scheme="https://92rw.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Maven项目的知识点</title>
    <link href="https://92rw.github.io/posts/1845b25c.html"/>
    <id>https://92rw.github.io/posts/1845b25c.html</id>
    <published>2023-10-09T08:00:00.000Z</published>
    <updated>2023-10-09T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本人JavaWeb学习笔记中的 <a href="https://github.com/92rw/Java-Study-Notes/blob/main/JavaWeb/JavaWeb16_Maven.md">在IDEA中配置Maven项目</a></p><p>依赖配置：依赖指当前项目运行需要的jar，一个项目可以设置多个依赖</p><h2 id="依赖传递">依赖传递</h2><p>直接依赖：在当前项目中通过依赖配置建立的依赖关系</p><p>间接依赖：直接依赖所依赖的资源</p><p>依赖冲突</p><ul><li>路径优先：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高（类似就近原则）</li><li>声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的</li><li>特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配靠的（应避免这种无意义冲突）</li></ul><p>可选依赖（隐藏依赖）：对外隐藏当前所依赖的资源。配置方式：在引入依赖时将 &lt;optional&gt; 设置为true</p><p>排除依赖：主动断开依赖的资源，被排除的资源无需指定版本。配置方式：在引入依赖时在 &lt;exclusions&gt; 指定组织编号和项目名</p><p>隐藏依赖是不让其他项目来引用（我不给），排除依赖是主动不要引入的某个资源（我不要）</p><h3 id="依赖范围">依赖范围</h3><p>依赖的jar默认情况可以在任何地方使用，在引入依赖时通过 &lt;scope&gt; 标签设定其作用范围</p><ul><li>主程序范围有效（src/main文件夹范围内）</li><li>测试程序范围有效（src/test文件夹范围内）</li><li>是否参与打包（package指令范围内）</li><li>compile（默认，在主程序、测试代码、打包都有效）</li></ul><table><thead><tr><th>scope</th><th>主代码</th><th>测试代码</th><th>打包</th><th>范例</th></tr></thead><tbody><tr><td>compile（默认）</td><td>√</td><td>√</td><td>√</td><td>log4j</td></tr><tr><td>test</td><td></td><td>√</td><td></td><td>junit</td></tr><tr><td>provided</td><td>√</td><td>√</td><td></td><td>servlet-api</td></tr><tr><td>runtime</td><td></td><td></td><td>√</td><td>jdbc</td></tr></tbody></table><p>解读：</p><ol><li>某个引入的jar包作用范围是程序员根据，业务的实际需要来设置的，不要认为是固定的。比如log4j jar包，在主程序，测试代码，打包都是需要的，因此作用范围应当设置为complie</li><li>junit只是测试代码需要，因此作用范围设置为test合适，但是如果程序员认为在主程序和打包就是要junit，仍然可以设置为默认compile</li><li>比如servlet-api是tomcat自己带的，当把程序打包放到生产环境时，用生产环境tomcat的servlet-api 即可，所以设置为provided合适，这样就防止servlet-api版本冲突</li><li>比如jdbc，是第三方的jar，打包放在生产环境，就应当在自已的包提供jdbc驱动包，否则程序会因为少驱动包，运行失败</li><li>细节：设置了scope属性后，该依赖无法传递到其他项目中</li></ol><h2 id="手动实现Maven项目">手动实现Maven项目</h2><ol><li><p>创建 D:\MyMaven 目录，子目录java-project-maven的结构如下：</p><ul><li>\src\main\java</li><li>\src\main\resources</li><li>\src\test\java</li><li>\src\test\resources</li></ul></li><li><p>创建 src\main\java\org\exerciese\Hello.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.exercise;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;sum=&quot;</span> + (n1 + n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建 src\test\java\org\exerciese\TestHello.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.exercise;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHello</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> hello.sum(<span class="number">10</span>, <span class="number">50</span>);</span><br><span class="line">        <span class="comment">//Assert 是一个断言类,(就是判断实际返回的值和期望值是否相同)</span></span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;sum=60&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建 \pom.xml 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        解读:modelVersion</span></span><br><span class="line"><span class="comment">        1. 描述这个pom文件/pom模型遵循的哪个版本</span></span><br><span class="line"><span class="comment">        2. 对应maven2 和 maven3 而言, 这里的modelVersion只能是4.0.0</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        解读: 下面是指定该项目的坐标, 是创建项目时，程序员指定</span></span><br><span class="line"><span class="comment">        1. groupId: 组织名</span></span><br><span class="line"><span class="comment">        2. artifactId: 项目名</span></span><br><span class="line"><span class="comment">        3. version: 版本</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.exercise<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-project-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        老师解读</span></span><br><span class="line"><span class="comment">        1. 这里就是引入项目需要的jar包, 类似传统项目的import jar的作用</span></span><br><span class="line"><span class="comment">        2. 在 dependencies标签内, 可以指定多个需要依赖的jar /导入jar</span></span><br><span class="line"><span class="comment">        3. 引入的jar包需要一个完整的jar包坐标, 从mvn仓库查询得到</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖jar的 groupId ： 组织名--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖jar的 artifactId ： 项目名--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖jar的 version ： 版本--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 该jar包的作用范围, 这里就是说引入的junit包，作用范围在 src/test。。目录下,</span></span><br><span class="line"><span class="comment">                 关于scope后面我们还会详解.</span></span><br><span class="line"><span class="comment">             --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="生命周期">生命周期</h3><ol><li><p>编译</p><ul><li><p>在项目根目录下进入cmd，输入如下指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br></pre></td></tr></table></figure></li><li><p>完成后会得到新建的 /target/classes 和 /target/maven-status 目录</p></li></ul></li><li><p>测试</p><ul><li><p>在项目根目录下进入cmd，输入如下指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li><li><p>命令行中会得到测试的总体报告、每个测试用例的报告，得到新建的 /test-classes 目录和 /target/surefire-reports 目录（输出运行结果）</p></li></ul></li><li><p>打包</p><ul><li><p>在项目根目录下进入cmd，输入如下指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure></li><li><p>完成后会得到 /target/maven-archiver 目录和打包的 /target/项目名-版本号.jar 文件</p></li></ul></li><li><p>安装</p><ul><li><p>在项目根目录下进入cmd，输入如下指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure></li><li><p>会把打包得到的 .jar，提交到本地仓库（如果修改了 settings.xml 配置的默认仓库路径，生成的 .jar 会在指定的仓库路径下），之后该 jar 也可以被本地其他 maven 项目使用</p></li></ul></li><li><p>清理</p><ul><li><p>在项目根目录下进入cmd，输入如下指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure></li><li><p>会清除target目录</p></li><li><p>应用场景：比如我们希望把源码进行拷贝或移植，或者希望来一次全新的bulid，就可以先进行clean</p></li></ul></li><li><p>总结</p><p>Maven构建命令使用mvn开头，后面添加功能参数，可以一次执行多个命令，使用空格分隔</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mvn compile <span class="comment">#编译</span></span><br><span class="line">mvn clean   <span class="comment">#清理</span></span><br><span class="line">mvn <span class="built_in">test</span>    <span class="comment">#测试</span></span><br><span class="line">mvn package <span class="comment">#打包</span></span><br><span class="line">mvn install <span class="comment">#安装</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Maven项目构建">Maven项目构建</h2><h3 id="生命周期的三大阶段">生命周期的三大阶段</h3><p>生命周期Lifecycle：一次构建过程经历了多少个事件，通过插件plugin实现</p><p>clean：清理工作</p><table><thead><tr><th>生命周期</th><th>对应事件</th></tr></thead><tbody><tr><td>pre-clean</td><td>执行一些需要在clean之前完成的工作</td></tr><tr><td>clean</td><td>移除所有上一次构建生成的文件</td></tr><tr><td>post-clean</td><td>执行一些需要在clean之后立刻完成的工作</td></tr></tbody></table><p>default：核心工作，例如编译，测试，打包，部署等</p><table><thead><tr><th>生命周期</th><th>对应事件</th></tr></thead><tbody><tr><td>validate（校验）</td><td>校验项目是否正确并且所有必要的信息，可以完成项目的构建过程</td></tr><tr><td>initialize（初始化）</td><td>初始化构建状态，比如设置属性值。</td></tr><tr><td>generate-sources（生成源代码）</td><td>生成包含在编译阶段中的任何源代码</td></tr><tr><td>process-sources（处理源代码）</td><td>处理源代码，比如过滤任意值</td></tr><tr><td>generate-resources（生成资源文件）</td><td>生成将会包含在项目包中的资源文件</td></tr><tr><td>process-resources（处理资源文件）</td><td>复制和处理资源到自标自录，为打包阶段最好准备。</td></tr><tr><td><strong>compile（编译)</strong></td><td><strong>编译项自的源代码</strong></td></tr><tr><td>process-classes（处理类文件）</td><td>处理编译生成的文件，比如说对javaclass文件做字节码改善优化。</td></tr><tr><td>generate-test-sources（生成测试源代码）</td><td>生成包含在编译阶段中的任何测试源代码。</td></tr><tr><td>process-test-sources（处理测试源代码）</td><td>处理测试源代码，比如说，过滤任意值。</td></tr><tr><td>generate-test-resources（生成测试资源文件）</td><td>为测试创建资源文件。</td></tr><tr><td>process-test-resources（处理测试资源文件）</td><td>复制和处理测试资源到目标目录</td></tr><tr><td><strong>test-compile（编译测试源码）</strong></td><td><strong>编译测试源代码到测试目标目录</strong></td></tr><tr><td>process-test-classes（处理测试类文件）</td><td>处理测试源码编译生成的文件</td></tr><tr><td><strong>test（测试）</strong></td><td><strong>使用合适的单元测试框架运行测试（Juint是其中之一）</strong></td></tr><tr><td>prepare-package（准备打包）</td><td>在实际打包之前，执行任何的必要的操作为打包做准备。</td></tr><tr><td><strong>package（打包）</strong></td><td><strong>将编译后的代码打包成可分发格式的文件，比如JAR、WAR或者EAR文件</strong></td></tr><tr><td>pre-integration-test（集成测试前）</td><td>在执行集成测试前进行必要的动作。比如说，搭建需要的环境</td></tr><tr><td>integration-test（集成测试）</td><td>处理和部署项自到可以运行集成测试环境中，</td></tr><tr><td>post-integration-test（集成测试后）</td><td>在执行集成测试完成后进行必要的动作。比如说，清理集成测试环境</td></tr><tr><td>verify(验证)</td><td>运行任意的检查来验证项目包有效且达到质量标准。</td></tr><tr><td><strong>install(安装）</strong></td><td><strong>安装项自包到本地仓库，这样项自包可以用作其他本地项自的依赖</strong></td></tr><tr><td>deploy(部署）</td><td>将最终的项目包复制到远程仓库中与其他开发者和项目共享。</td></tr></tbody></table><p>site：产生报告，发布站点等</p><table><thead><tr><th>生命周期</th><th>对应事件</th></tr></thead><tbody><tr><td>pre-site</td><td>执行一些需要在生成站点文档之前完成的工作</td></tr><tr><td>site</td><td>生成项目的站点文档</td></tr><tr><td>post-site</td><td>执行一些需要在生成站点文档之后完成的工作，并直为部署做准备</td></tr><tr><td>site-deploy</td><td>将生成的站点文档部署到特定的服务器上</td></tr></tbody></table><p>生命周期的分阶段执行</p><ul><li>项目构建生命周期分很多阶段，并不是每次都完整执行，而是根据用户的要求来执行的</li><li>比如执行compile，那么就执行到compile这个阶段；如果执行install，则会执行compile→test→package→install</li></ul><h3 id="插件">插件</h3><p>官方文档：<a href="https://maven.apache.org/plugins/index.html">Maven – Available Plugins (可用插件)</a></p><p>插件与生命周期内的某个阶段绑定，在执行到对应生命周期时，由对应插件来完成任务/功能</p><p>使用方式：在pom.xml文件的 &lt;build&gt;→&lt;plugin&gt; 标签中引入</p><p>除了插件的坐标外，通过 &lt;executions&gt; 标签中的 &lt;execution&gt; 配置执行的操作内容：&lt;phase&gt; 指定调用阶段，&lt;goals&gt;指定执行结果（可在 <a href="https://maven.apache.org/plugins/maven-source-plugin/">Goals Overview</a> 查看相关说明）</p><p>说明：</p><ul><li><p>项目对象模型POM，主要作用是依赖Dependency管理</p></li><li><p>在maven项目构建生命周期中，每个阶段的执行都有相应的插件完成</p></li><li><p>各个插件执行过程中，会附带输出内容，比如jar/war/xml/源码</p></li><li><p>程序员可以使用maven默认的插件，也可以自定义插件，完成定制任务</p></li></ul>]]></content>
    
    
    <summary type="html">使用Maven管理Java项目的一些概念和参数</summary>
    
    
    
    <category term="Coding" scheme="https://92rw.github.io/categories/Coding/"/>
    
    
    <category term="编程" scheme="https://92rw.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>蒙特卡罗方法验证出生率</title>
    <link href="https://92rw.github.io/posts/148c7e38.html"/>
    <id>https://92rw.github.io/posts/148c7e38.html</id>
    <published>2023-10-02T22:00:00.000Z</published>
    <updated>2023-10-02T22:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>2012年2月，博主 @奥卡姆剃刀 发表了一条微博</p><blockquote><p>某国生男生女比例为1:1，国王为了抵御外敌入侵下令城民头胎生男者可续生，生女者禁生，几十年后，该国的男女比例能增加吗？</p></blockquote><p>按照常理，这样的政策执行应该不会对人口比例造成影响，然而教主 @tombkeeper 却经过枚举验证，得到了不一样的结论</p><p><img src="https://static-resources.vercel.app/posts/Algorithm-birthratio.png" alt="微博截图"></p><div class="note info flat"><p>源微博链接：<a href="https://weibo.com/1401527553/y5hUMDoD0">https://weibo.com/1401527553/y5hUMDoD0</a></p></div><p>教主的验证代码由C语言编写，由于我尚未学习C语言，只能向ChatGPT求助。</p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">教主的源源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">ChatGPT重构后</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">\```C</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FEMALE 0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> f = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">//一百万75%的概率生男孩的家庭</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">1000000</span> ; i++) &#123;</span><br><span class="line">        s = rand() %<span class="number">2</span> | rand() %<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == MALE) &#123;</span><br><span class="line">            m++;</span><br><span class="line">            <span class="comment">//若头胎男孩再生一胎</span></span><br><span class="line">            s = rand() %<span class="number">2</span> | rand() %<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (s == MALE) &#123;</span><br><span class="line">                m++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一百万75%的概率生女孩的家庭</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">1000000</span> ; i++) &#123;</span><br><span class="line">        s = rand() %<span class="number">2</span> &amp; rand() %<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == MALE)&#123;</span><br><span class="line">            m++;</span><br><span class="line">            <span class="comment">//若头胎男孩再生一胎</span></span><br><span class="line">            s = rand() %<span class="number">2</span> &amp; rand() %<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (s == MALE) &#123;</span><br><span class="line">                m++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MALE:FEMALE = %d:%d\n&quot;</span>, m, f);</span><br><span class="line">&#125;</span><br><span class="line">\```</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FEMALE 0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> f = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">// 一百万75%的概率生男孩的家庭</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">1000000</span> ; i++) &#123;</span><br><span class="line">        s = (rand() % <span class="number">4</span>) &lt; <span class="number">3</span> ? MALE : FEMALE; <span class="comment">// 75% 的机会是 MALE</span></span><br><span class="line">        <span class="keyword">if</span> (s == MALE) &#123;</span><br><span class="line">            m++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一百万75%的概率生女孩的家庭</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">1000000</span> ; i++) &#123;</span><br><span class="line">        s = (rand() % <span class="number">4</span>) &lt; <span class="number">3</span> ? FEMALE : MALE; <span class="comment">// 75% 的机会是 FEMALE</span></span><br><span class="line">        <span class="keyword">if</span> (s == MALE)&#123;</span><br><span class="line">            m++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MALE:FEMALE = %d:%d\n&quot;</span>, m, f);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>上述代码中体现了这些知识点：</p><ol><li><p>计算随机数的方法</p><p>在C语言中，<code>rand()</code> 函数返回的是一个随机整数，范围是从0到<code>RAND_MAX</code>，其中 <code>RAND_MAX</code> 是一个预定义的常数，在大多数系统上，它的值是32767。</p></li><li><p>按位运算</p><p>计算机的数值计算的底层逻辑，可以提高计算速度。它并不特定于任何一种语言，C和Java都支持位运算，并且它们的效率都是比较高的。但在这个特定的问题中，我们并不需要使用位运算，因为我们不是在处理位级别的操作，我们只是生成随机数并进行比较。</p></li><li><p>对概率的模拟</p><p>ChatGPT认为：<code>rand() % 2</code> 生成的是0或1，这意味着有50%的概率得到0或1。代码中使用了按位或（<code>|</code>）和按位与（<code>&amp;</code>）操作符，实际上并没有改变这个概率。</p></li><li><p>蒙特卡罗算法</p><p>也称<strong>统计模拟方法</strong>，使用随机数（或更常见的伪随机数）来解决很多计算问题的方法。 将所求解的问题同一定的概率模型相联系，用电子计算机实现统计模拟或抽样，以获得问题的近似解。</p></li></ol><p>同时，ChatGPT也使用Java语言重写了上面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenderRatio</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MALE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FEMALE</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> s;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一百万75%的概率生男孩的家庭</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            s = ((<span class="type">int</span>) (Math.random() * <span class="number">4</span>) &lt; <span class="number">3</span>) ? MALE : FEMALE;</span><br><span class="line">            <span class="keyword">if</span> (s == MALE) &#123;</span><br><span class="line">                m++;</span><br><span class="line">                s = ((<span class="type">int</span>) (Math.random() * <span class="number">4</span>) &lt; <span class="number">3</span>) ? MALE : FEMALE;</span><br><span class="line">                <span class="keyword">if</span> (s == MALE) &#123;</span><br><span class="line">                    m++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一百万75%的概率生女孩的家庭</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            s = ((<span class="type">int</span>) (Math.random() * <span class="number">4</span>) &lt; <span class="number">3</span>) ? FEMALE : MALE;</span><br><span class="line">            <span class="keyword">if</span> (s == MALE) &#123;</span><br><span class="line">                m++;</span><br><span class="line">                s = ((<span class="type">int</span>) (Math.random() * <span class="number">4</span>) &lt; <span class="number">3</span>) ? FEMALE : MALE;</span><br><span class="line">                <span class="keyword">if</span> (s == MALE) &#123;</span><br><span class="line">                    m++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;MALE:FEMALE = %d:%d\n&quot;</span>, m, f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码中，<code>(int) (Math.random() * 4)</code> 生成了一个0到3的随机整数。然后我们比较这个数是否小于3来决定性别。如果是，则有75%的机会是男孩（或女孩，在第二个循环中）。这里我们没有使用位运算，因为在这个情况下，位运算并不提供任何实际的好处，并且可能使代码更难理解。</p><p>从数学逻辑上对结果进行分析：</p><p>代码中设定的条件不是完全随机。当前代码在两个循环中分别模拟了两种情况：</p><ol><li>第一个循环中，有75%的概率生男孩的家庭。</li><li>第二个循环中，有75%的概率生女孩的家庭。</li></ol><p>在两个不同的情况中，都没有严格遵循自然界的男女出生概率。</p><p>也就是说，教主在微博评论区中提到的“两百多年来只诞生过两位女性”的家庭，也是自然界对真正的随机情况（即，每个孩子出生都是独立事件，且男孩和女孩的出生概率相等）的一种补充，有的家庭中女孩有更高的出生率，来平衡这种男性单传的现象。</p><p>再换一个角度看，也许有的人在赌博中连赢，也是在数学概率上有些人爆亏来平衡比率的结果，这样想是不是有点走向宿命论了？</p>]]></content>
    
    
    <summary type="html">真实世界的随机概率，超出了日常观念中的认知</summary>
    
    
    
    <category term="Algorithm" scheme="https://92rw.github.io/categories/Algorithm/"/>
    
    
    <category term="算法" scheme="https://92rw.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算王工程算量笔记</title>
    <link href="https://92rw.github.io/posts/55a5f976.html"/>
    <id>https://92rw.github.io/posts/55a5f976.html</id>
    <published>2021-12-21T00:00:00.000Z</published>
    <updated>2021-12-21T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>3.电气算量</h1><h2 id="配管和配线计算方法">配管和配线计算方法</h2><p>配线计算：在配线数量中输入线管数量，选择主项信息后，设置相关项选择“配线”<br>计算横向线管：识别图元并设置“配线数量”后，切换到“鼠标选择测量状态”，按住Ctrl键并框选线管和数量标识。在相关项中选择“配线”<br>计算立管高度：设置“立管高度”后，选中需要布置立管的设备，鼠标右键选择“快速布置立管”（立管根数和与之相连的横管一致）。在相关项中选择“配线”</p><h2 id="上桥架的电缆计算方法">上桥架的电缆计算方法</h2><p>水平桥架：鼠标切换到“桥架线槽”<br>竖向桥架：设置高度，鼠标切换到“桥架立管”<br>计算纯桥架上的电缆：切换到“测量尺状态”，点击进出线端点，电缆将沿桥架自动布置。计算规则：X<em>1.025<br>电缆计算：计算式X</em>W，设置相关项为“电缆走管”和“电缆走桥架”<br>管内穿线：“测量尺状态”选择后，用数字键切换穿的线数量，设置相关项为“线走管”和“线走桥架”</p><h1>4.给排水算量</h1><h2 id="基本操作">基本操作</h2><ul><li>算量原则<br>先算管道长度，再算与管道规格相关的数量（阀门、套管等）和其他（刷油、保温）</li><li>计算前小功能说明：<br>1.底图颜色及透明度切换以及底图处理功能和测量线宽调整（便于算量及查看）<br>底图状态下选中图纸，右键选择“底图处理”，根据需要进行相关项目选择。<br>2.定义系统图（双窗口显示图纸，方便对比查看）<br>底图状态下选中图纸，鼠标右键“定义为系统图”，按Q键可隐藏或显示<br>3.检查比例及调整比例：测量轴网或已知长度的线查看比例若不对调整比例<br>①图纸窗口中右键选择倍数（例如室外放大1000倍）<br>②横纵各选择一根线，在上方“比例尺设置”中调整<br>4.口算手动输入工程量<br>固定长度的测量：在立管窗口输入长度，在图纸中线段端点处点击鼠标左键，然后右键选择“固定长度或桥架”<br>5.跨图纸复制图元<br>6.设置数据模板：用于批量修改支架类型、重量等，以便后续代入公式<br>支架重量计算公式G/2.5*1.8，G代表总计量的数量</li></ul><h2 id="长度计量">长度计量</h2><h3 id="方法一：传统手工测量">方法一：传统手工测量</h3><p>水平管：①测量尺手工划线，单项添加工程量②利用【水管批量识别】测量计算（不同规格可以同时测量，一起添加）<br>步骤：打开【系统图显示窗口】查看系统图，工具栏DN下拉框选择【水管批量识别】，勾选要计算规格，点击【测量尺】，沿CAD线量取。<br>竖向长度：在立管输入栏输入高度，使用【布置立管】进行点布（按住CTRL键点布立管到已知规格测量线上）。<br>划线技巧：①按住Shift键可以正交划线②按空格快速切换最近使用过的两个工具③按ALT键可以快速切换立管工具</p><h3 id="方法二：半自动识别（过渡办法）">方法二：半自动识别（过渡办法）</h3><p>利用【水管批量识别】功能把所有管道识别完按一种规格添加工程量然后再把不同规格的管道变更出来，立管部分可以手动改也可以属性刷进行设置</p><h3 id="方法三：水管批量识别步骤">方法三：水管批量识别步骤</h3><p>（1）点击DN下拉菜单【水管批量识别】<br>（2）【识别条件】默认设置，平面图管道有规格勾选“识别规格”，【设置配置表】选中对应管道规格（可批量修改管道材质和规格）（在使用的管道规格前打对勾）（立管识别后长度为0，可进入属性刷修改）<br>（3）鼠标在【底图选择状态】，选中一段水管，点击批量识别窗口【开始识别】<br>（4）勾选一个规格，鼠标变成“规格刷”状态，点击（或框选）与此规格对应的测量线。<br>（5）竖向立管处理方法：【水管批量识别】窗口下方【属性刷】功能界面，勾选【立管】，输入x立管高度，勾选【属性刷启动状态】，点击（或框选）此高度立管，立管高度自动生成。地漏/马桶/洗手盆等处短立管用“快速布置立管识别”<br>（6）工程量添加方式<br>方式一：在分组名称分组《114）多右键【设置分组名称】，再右键【添加此组数据到工程】即可<br>方式二：【按规格汇总添加】，然后删除数据行下方“未匹配”数据行</p><h2 id="数量计算">数量计算</h2><p>基本方法：【计数标记】在图纸中一个一个点数<br>（1）卫生洁具及其他设备（CAD一种图例只代表一种）<br>【底图选择状态】，选中设备，鼠标右键【快速数数量】<br>在右侧区域添加角阀等附属配件<br>（2）阀门（应先算完管道后再统一计算阀门）<br>算完管线，【底图选择状态】。选中阀门，“批量数数量”下拉菜单【根据已添加测量线结合底图图元数数量】功能，这样同种阀门就会根据管道的管径来统计出来<br>要求：①测量水平段管道②测量线经过测量图形<br>（3）套管<br>在有套管的地方画上测量线（分段划线）与已添加管线相交，“批量数数量”下拉菜单【根据当前测量线和已添加测量线相交数数量】，套管就会按照不同规格的管道统计出来<br>（4）管件计算<br>利用下方表格的【过滤】功能选择需要检查或调整的项目，可实现分系统读取。修改完后刷新<br>在计算完管道后，点击上方工具栏中【读取管件】，按配置需求填写后，识别添加</p><p>4、其他相关量<br>刷油、保温：勾选要添加的相关项（例如“管道刷油面积”），在规则的下拉框中选择相应的管道规格<br>支架：相关项【添加一行】，规则调整：c/支架间距*支架重量（间距和重量按照实际工程要求填写上数值）<br>然后勾选数据窗口要添如的数据行，使用【添加页上勾选的相关项添加到勾选组】（可以同时勾选刷油、保温等多项）<br>5、地暖管算量（未涉及此处地区可忽略）<br>（1）管道长度快速测量<br>1.先用【底图处理】，只显示地暖管道图层，拉框选择管道，快速测量<br>2.利用【水管批量识别】功能把所有管道识别完，按一种规格添加工程量再把不同规格管道变更出来，立管部分可以手动改也可以属性刷进行设置<br>3.输入立管长度，选择设备和属性标注，【根据已添加测量线布置立管】<br>（2）采暖面积的测量（革板、钢丝网、反射膜）<br>点击【测量面积】，沿着面积的边界测量，右键确定<br>（测量面积的时候是不可以撤销上一步的，但是可以移动端点的位置，注意画法，不<br>要相交）<br>六、拆分工程量（所有工程量计算完后使用）<br>七、汇总检查导出</p><h1>5.消防算量</h1><p>主要计算内容：管道、阀门、套管、管件，算量原则：先算管道长度，再算辅助配件<br>基本操作：选中喷头、文字、管道，鼠标右键“只显示图元所在图层”<br>底图处理→图层选择管理器</p><h2 id="喷淋管道批量识别">喷淋管道批量识别</h2><h3 id="1-按规格分开识别：">1.按规格分开识别：</h3><p>①底图选择状态，选中标注及管道，点击“消防快速布线”（上方DN图形）<br>存在问题：缺乏标注的管道需手动添加<br>计算原则：先大管后小管，先平面后立面<br>②添加计算规则：相关项中选中“管道刷油面积”，在规则列表中选中管道规格；此处可选择支架计算的规则<br>③喷头短立管识别：输入立管高度，选中喷头图元，右键“快速布置立管”</p><h3 id="2-消防管道批量识别（立管自动生成）：">2.消防管道批量识别（立管自动生成）：</h3><p>①底图选择状态，选中喷头和管道，“喷淋管道批量识别”</p><ul><li>识别条件：图层、颜色、线型</li><li>立管高度：在表格中设置</li><li>安全级别：若标注完整，表格中选择“标注优先”，表格中的对应喷头数可双击修改</li><li>管道规格：勾选图纸中存在的规格</li></ul><p>点击“开始识别”<br>②识别效果排查：a进水端b主管的位置和范围c没有管径的I值<br>喷淋系统中，I值代表管道连接的喷头数量<br>单机分区会显示为粉红色。<br>设置对话框→图元尺寸设置</p><ul><li>1.提示“只有喷头”。因喷头错位，图纸错误等引起的孤零零的喷头<br>解决：a移动喷头到线的端点处（集体选中按W移动）；b若喷头多余删除</li><li>2.提示“无喷头”：因图纸错误或漏画喷头以及喷头错位引起的孤零零的水平管<br>解决：a移动或者补画喷头（立管）到线的端点处；b若多余则删除；c若主管则设置管径</li><li>3.提示“可能缺少连接的管道”：因图纸错误引起该连通的管道没连上<br>解决：根据图纸手动链接即可，没连接上的管道增加测量线接入。系统的消防给水管，选中管道右键，设置为主管</li><li>4.提示“无可能的进水管（进水管不确定）”：软件怀疑图纸上有多个进水管<br>解决：双击“可能的进水管”定位到对应测量线，确定是否正确，然后鼠标右键【设置为进水管】；</li><li>4.提示“可能存在一丢丢小问题：图纸存在管道断点”<br>解决：检查断点处并且设置供水管工值（供水喷头的个数），可添加高度为0的立管，并设置I值定义管径</li><li>6.提示“可能存在一丢丢小问题：管道有供水死循环”<br>解决：根据图纸删除错误管道（先点下分区找到哪个区域，再点下进水管找到进水端排查供水关系）</li><li>7.双喷或者侧喷问题<br>解决：选中双喷或侧喷头，设置立管高度后右键“快速布置立管”，选中含喷头的管道右键“设置为双喷头/设置为侧喷头”（可使用查找功能快速定义这种图形）。对于侧喷头可输入“立管高度[侧喷]”加入备注</li></ul><p>③数据添加<br>点击【按规格汇总添加】。若需分组添加，在分组上右键【设置分组名称】，再右键【添加此组数据到工程】即可（也可将每组设置名称后，点击分区域添加整体添加）<br>注意：清晰的认识到软件的识别原理，即根据喷头个数判断管径+根据管道标注同时进行识别并且两条识别路线互不干扰；<br>④拆分工程量<br>框选图纸区域，鼠标右键，“拆分工程量”</p><h2 id="消火栓系统快速计算">消火栓系统快速计算</h2><h3 id="方法一：传统手工测量-2">方法一：传统手工测量</h3><p>水平管：</p><ul><li>1.测量尺手工划线，单项添加工程量</li><li>2.利用【水管批量识别】测量计算（不同规格可以同时测量，一起添加）<br>步骤：打开【系统图显示窗口】查看系统图，工具栏DN下拉框选择【水管批量识别】， <strong>勾选要计算规格</strong> ，点击【测量尺】沿CAD线量取。</li></ul><p>竖向长度：在立管输入栏输入高度，使用【布置立管】进行点布（按住CTRL键点布立管到已知规格测量线上）。<br>划线技巧：1.按住Shift键可以正交划线2.按空格快速切换最近使用过的两个工具3.按ALT键可以快速切换立管工具</p><h3 id="方法二：水管批量识别步骤">方法二：水管批量识别步骤</h3><p>【底图选择状态】选择消火栓图元和一段消火栓管道，点击上方工具栏DN下拉菜单【水管批量识别】，在“设置配置表”选择管道材质和尺寸。勾选一个规格鼠标变成【规格刷】状态，点击（或框选）与此规格对应的测量线<br>图纸中绿色表示规格未识别。<br>启用规格刷，框选范围实现选择：①在表格中的规格打勾②按键盘快捷键③按Ctrl框选已知规格的管道<br>通过查找功能选中，鼠标右键“属性”修改参数<br>点击“打开属性刷”，设置立管高度后统一修改立管高度<br>管道自动连接：取消规格刷，在鼠标选择状态下框选管道端点，按键盘J键自动连接<br>竖向立管处理方法：【水管批量识别】窗口下方【属性刷】功能界面，勾选【立管】，输入x立管高度，勾选【属性刷启动状态】，点击（或框选）此高度立管，立管高度自动生成。<br>数据添加：操作方法同喷淋系统<br>操作步骤：规格刷→接断点→属性刷<br>结果复核：在下方表格选择“只显示本组测量图元”</p><h2 id="管件识别">管件识别</h2><p>（0）设置防火分区等<br>绘制测量线，选择“测量线打断”。“区域选择”<br>（1）消火栓、喷淋头、末端试水装置等（不需要根据管道规格区分的设备）<br>快速数数量：【底图选择状态】，选择图元后鼠标右键【快速数数量】<br>（2）阀门<br>算完管线，【底图选择状态】选中阀门，“批量数数量”下拉菜单【根据已添加测量线结合底图图元数数量】功能，这样同种阀门就会根据管道的管径来统计出来。在下方“设置”输入阀门名称，点击“添加”<br>系统图中的阀门：a.快速数数量，然后根据情况鼠标右键“变更”操作；b.给系统图中的管道添加管径，剩余同上<br>对于不是图块的图形，可以用“快速数数量”将其转换为图块<br>（3）套管<br>在有套管的地方画上测量线与已添加管线相交&quot;下拉菜单【根据当前测量线和已添加测量线相交数数量】，套管就会按照不同规格的管道统计出来<br>（4）管件计算<br>在计算完管道后，点击上方工具栏中【读取管件】凸，按配置需求填写后，识别添加</p><h2 id="支架计算">支架计算</h2><p>支架的选材：单根DN100、单根DN150的管道一般会选5#角钢或5#槽钢或6#槽钢；两根共用支架时会选8#或10#槽钢；三根管共用时会选10#或12#槽钢；DN50DN80在喷淋中用量较小，DN65在消火栓中用量较多，一般按5#角钢考虑；DN25DN40一般按3#或4#角钢考虑。<br>喷淋管支架大致估算：150 .100管按5#槽钢间距4.5米，“U”型支架，单个支架用材1.5米计，80.65.50管按5#角钢间距4.5米，“U”型支架，单个支架用材1.5米计，40.32. 25管按4#角钢间距3.5米，“L”型支架，单个支架用材1.2米</p><h1>6.暖通算量</h1><h1>风管面积测量</h1><p>选中文字后鼠标右键“选中相同文字”，将对应文字颜色标记。<br>用测量尺测量长度，选中文字后在数据添加页右键添加。<br>计算规则X*(L+W)*2<br>##通风管道批量识别</p>]]></content>
    
    
    <summary type="html">为了提高投标算量的工作效率，总结了一些使用经验</summary>
    
    
    
    <category term="Scribble" scheme="https://92rw.github.io/categories/Scribble/"/>
    
    
    <category term="软件使用" scheme="https://92rw.github.io/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>算王软件界面及常用功能</title>
    <link href="https://92rw.github.io/posts/c2885da.html"/>
    <id>https://92rw.github.io/posts/c2885da.html</id>
    <published>2021-12-20T00:00:00.000Z</published>
    <updated>2021-12-20T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1.算量窗口</h1><ul><li>上方工具栏<br>1.1底图选择状态：可选中多个图元，右键后可对其进行底图处理；<br>鼠标选择状态：一次只能选择一个图元<br>1.2测量尺状态<br>1.3布置立管按钮：需首先输入立管长度，也可输入计算式<br>1.4计数标记<br>1.5桥架测量：若桥架相连，其中一侧的首末段必须在另一个的框内<br>1.6桥架立管：可与横向桥架相连，图纸中的长度不影响算量长度</li><li>上方图形区<br>1.7底图颜色显示状态：可切换底图颜色显示的状态，以及透明度<br>设置对话框：选择测量图元的尺寸（大小、线宽）</li><li>右侧<br>1.8数据添加页<br><em>添加方法</em><br>①从图形中选中文字，在数据添加页右键提取②选中图元，Ctrl+C再Ctrl+V③从主项模板数据中选择④直接输入<br><em>设置相关项</em><br>计算开关盒、配管工程量等，与主项共享测量图元</li><li>下方<br>编辑状态：只能通过“序号”行对应表格，</li></ul><h1>2.算量方法</h1><ol><li><p>点数标记</p><p>在“计数标记”状态下点击图元，用于无标记或标记不全的图例</p></li><li><p>快速数数量</p><p>测量单个图元：选中图元，鼠标右键选择“快速数数量”</p><p>测量图元组：切换到底图选择状态，鼠标右键选择“快速数数量”</p></li><li><p>长度量计算</p><p>测量尺状态/布置立管</p></li></ol><h1>3.测量结果修改</h1><h2 id="3-1-修改测量公式">3.1 修改测量公式</h2><p>测量图元右键“属性”，可对多个图元同时修改<br>测量规则为G，可计算开关盒、插座盒等<br>在测量图元属性窗口，可批量修改图元的数值，如X公式输入-1，则所有数值变为“原值-1”，若需要改为-1，则公式需为“1*（-1）”<br>通过数字键可批量修改I值</p><h2 id="3-2-选中图元">3.2 选中图元</h2><p>测量状态的图元：①右键“选中当前测量”②Ctrl+A③“测量尺状态”的下拉菜单，选中当前测量线/选中当前立管<br>已测量图元：利用鼠标框选，按住Ctrl再框选可以增加或删除选中的区域<br>选中相同立管：选中其中一个立管，“测量尺状态”的下拉菜单<br>通过查找功能选中图元：可查找满足条件的图元，可指定查找范围：底图/测量图元（当前图元/已添加图元/图元类型）<br>线条合并为一个图形：选中线条，右键“快速数数量”，右键“选中当前测量”，右键“删除快速标记”</p><h2 id="3-3调整图元位置：">3.3调整图元位置：</h2><ul><li>在图纸中移动<br>单个图元移动：选中相连图元，按住Ctrl再移动，可将图元带着相连的测量线一起移动<br>整体移动：选中区域，按快捷键W，通过鼠标移动</li><li>调整所在项<br>选中图元，鼠标右键选择“变更”（快捷键Ctrl+D），在目标项双击“关联”或右键“当前测量图元添加到本组”</li></ul><h2 id="3-4-拆分工程量">3.4 拆分工程量</h2><p>将需要拆分的区域选中，鼠标右键选择“拆分工程量”（快捷键Ctrl+B）<br>计算倍数可在原值上加/乘<br>文字信息可在原值前后添加</p><h2 id="3-5-数据窗口的表格">3.5 数据窗口的表格</h2><p>调整顺序：选中后Ctrl+X剪切后粘贴<br>删除某行：选中，删除勾选行<br>按要求选择某行：过滤<br>修改勾选行：先勾选需要修改的行<br>水平竖向分列：表格内右键“表格设置”，选择“水平竖向分开”</p>]]></content>
    
    
    <summary type="html">算量软件可以在工程投标时节省很多时间精力</summary>
    
    
    
    <category term="Scribble" scheme="https://92rw.github.io/categories/Scribble/"/>
    
    
    <category term="软件使用" scheme="https://92rw.github.io/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Office操作笔记</title>
    <link href="https://92rw.github.io/posts/6483be8b.html"/>
    <id>https://92rw.github.io/posts/6483be8b.html</id>
    <published>2021-08-28T00:00:00.000Z</published>
    <updated>2021-08-28T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Office的工具使用</h1><h2 id="邮件合并填Word表格">邮件合并填Word表格</h2><p>Office自带的邮件合并功能确实更好用，因其可视化程度高而胜过python。<br>工作步骤：</p><ul><li>检查确保Excel首行为标题字段</li><li>调整好Word格式后，点击上方“邮件”选项卡<ul><li>“开始邮件合并”→“邮件合并分步向导”，点击“下一步：开始文档”</li><li>选中“使用当前文档”，点击“下一步：选中收件人”</li><li>选中“使用现有列表”，点击“浏览”导入Excel中对应工作表，点击“下一步：撰写信函”</li><li>鼠标选择填写数据的位置，点击右侧导航栏“其他项目”，选择对应标题字段，点击“下一步：预览信函”</li><li>确认合并情况无误，点击“下一步：完成合并”</li><li>点击“编辑单个信函”，根据需要选择范围</li></ul></li></ul><p>如果希望插入图片</p><ol><li>在Excel中标记图片地址，注意<code>\</code>应写为<code>\\</code></li><li>在Word点击上方“插入”选项卡，选择右侧“文档部件”</li><li>选择“域”后左侧菜单“连接和引用”中选择“IncludePicture”，域属性输入“其他”，（域选项勾选“未随文档存储的数据”）</li><li>选中新增的内容，按<code>Alt+F9</code>，（选中“其他”，按<code>CTRL+F9</code>加入大括号，在前面输入<code>&quot;if true &quot;</code>）。将“其他”替换为“邮件”选项卡中“插入合并域”的内容<br>*</li><li>若依旧没有显示，全选后按<code>F9</code>即可</li></ol><p>如果希望将做好后的部分分拆至不同文件：</p><ol><li>点击上方“引用”选项卡，选择左侧“添加文字”为1级</li><li>点击上方“视图”选项卡，选择左侧“大纲”，在“显示级别”下拉菜单选择“1级”</li><li>按住键盘Shift键将其全选，点击“显示文档”全选后点击“创建”</li><li>将文件另存为，将得到独立文件`</li></ol><h2 id="Excel-的功能">Excel 的功能</h2><p>装了个叫“方方格子”的插件，从单元格里提取文字、数字十分方便。除此之外还有</p><ul><li><a href="https://www.bilibili.com/video/BV184411C7Ci">Excel视频教程</a></li><li>冻结窗格<br>点击上方“视图”选项卡，点击“拆分”将十字线定位后选择“冻结窗格”</li><li>邮件合并<br>虽然openpyxl结合pandas能填表，但写程序毕竟话费时间。有个叫<a href="https://www.bilibili.com/video/BV1i54y1V7Ac">艾敦制表神器</a>的程序很管用。</li></ul><h2 id="酷炫PPT">酷炫PPT</h2><p>以前还专门下载十几G的ppt素材，大部分都是只通过图片介绍预览了大致的界面。自从装了“iSlide”之后这一步也省了。</p><ul><li><strong>平滑过渡</strong> 在B站能找到关于这个的<a href="https://www.bilibili.com/video/BV1y54y1p7Pe">视频教程</a>，iSlide也能实现。但是我毕竟写ppt的机会很少，以后要有也是用统一模板，没有那么迫切的必要</li></ul>]]></content>
    
    
    <summary type="html">虽然现在我很少打开Office，但是当时工作要用</summary>
    
    
    
    <category term="Scribble" scheme="https://92rw.github.io/categories/Scribble/"/>
    
    
    <category term="软件使用" scheme="https://92rw.github.io/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>工程软件使用笔记</title>
    <link href="https://92rw.github.io/posts/d5e24b4c.html"/>
    <id>https://92rw.github.io/posts/d5e24b4c.html</id>
    <published>2021-08-27T00:00:00.000Z</published>
    <updated>2021-08-27T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CAD的操作笔记">CAD的操作笔记</h2><p>从大学起AutoCAD和Revit就一直常驻电脑，然而很多时候还是感觉自己水平不够，需要时常学习。然而我又不是整天对着电脑画图，学完之后一段时间不用就忘了怎么操作。借此机会记录一些常用的操作，以便日后节省时间。</p><h3 id="CAD操作笔记">CAD操作笔记</h3><ul><li><p>快捷键的使用</p><p><a href="https://www.autodesk.com.cn/shortcuts/autocad">官方文档</a> 中列出了各种快捷键，但是我觉得平时常用的也就只是其中几个而已。</p></li><li><p>视口的使用</p><p>在模型界面，输入vports将界面划分开</p><p>输入<code>mv</code>框选视口的范围，还可以设置其标注比例、限定显示的图层，对于按标准尺寸打印图纸十分有帮助。</p><blockquote><p>laymcur设定为当前图层<br>v视口编辑器<br>mv新建视口<br>rec添加矩形<br>layer隐藏不必要图层<br>MV-LO-ON锁住视口<br>MV-LO-OFF打开视口<br>“layvpi+回车”就是在当前视口之外的其它所有视口冻结当前选择对象所在的图层。<br>“layfrz+回车”就是在当在当前视口冻结选择对象所在的图层。</p></blockquote><p>解决视口线型不显示问题： PSLTSCALE设置为1</p></li></ul><h3 id="Revit操作笔记">Revit操作笔记</h3><p>好久没用了，近期的工作内容和Revit的关系并不大，等以后有机会了再补充。</p>]]></content>
    
    
    <summary type="html">使用AutoCAD的一些经验</summary>
    
    
    
    <category term="Scribble" scheme="https://92rw.github.io/categories/Scribble/"/>
    
    
    <category term="软件使用" scheme="https://92rw.github.io/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>我的麻将经历</title>
    <link href="https://92rw.github.io/posts/2c75f0f0.html"/>
    <id>https://92rw.github.io/posts/2c75f0f0.html</id>
    <published>2021-08-26T00:00:00.000Z</published>
    <updated>2021-08-30T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="心路历程">心路历程</h2><p>一直觉得麻将牌相互碰撞的声音十分悦耳，在大学之前却没多少机会实操上手，直到大学期间随大流接触了《雀魂》游戏。原本以为多打几局就能迅速上手，结果一方面自己沉迷断幺九浪费大量时间，另一方面被各种概率下的骚操作虐到怀疑人生，技术也未曾有多大长进。之后也就没什么机会接触雀魂了，只觉得那东西是消磨时间的一种方式而已。毕业之后也没怎么接触麻将，在2020年和同事组过雀魂友人局，2021年过年期间和同事打过线下麻将（屁胡），一共没玩多长时间。</p><p>2021年7月22日的线下麻将，让我重燃麻将瘾。然而至今不知道牌怎么摞，起章从哪拿这些国标麻将的内容。也就更不了解日麻怎么翻宝牌、怎么算番之类的。不过雀魂是实打实地玩起来了，在8月把四人和三人的等级都提升到雀杰，然后又看完了《魔女BLOG初中級日麻讲座（简中翻译第2版）》，于是又开小号希望能洗掉自己尴尬的失败率。然而自己毕竟实践不足经验欠缺，在牌桌上经常根据自己喜好对落单的单张牌随意摸切，不考虑牌河和牌效率，然后在几轮后摸到凑搭子的牌，只能扔进弃牌区望洋兴叹。</p><p>原以为一个月的学习能让自己的水平有所提高，然而在8月22日的线下麻将中，依然感受到了自己水平的不足。虽说自己起手不如人，但是在自己多向听、且接近流局情况下仍不做防守，以至于我成了庄家轮转的推动者，确实是自己水平不足。</p><p>线上麻将也不乐观，感觉现在雀魂低等级房间也是各路高手们在开小号互相比技巧，以至于我在银之间的小号成绩比在金之间的雀杰号更狼狈，更别说自己一局从领先第二名2万分，连续两个役満大铳被飞了，在有优势的情况下仍不收手，这是之前玩南风局就没改正的坏习惯。</p><p>最近开始在B站搜索麻将的视频，原本是看各路神仙玩大牌的，实践中发现光起手我就难以匹及，最后还是科学麻将的一些教学更符合我的非酋特性。8月份开始补番《天才麻将少女》，到8月底补完第一季和阿知贺篇，全国篇也就看到前面几集。</p><p>这一个月的时间内，晚上因为沉迷麻将疏于锻炼，养成了不好的习惯。总结了如上经历，我觉得像胡适那样沉迷打牌确实不好，写下这篇总结之后我要开始改变。因此决定自8月26日起，每天不再打雀魂，下班后的时间专注日语学习。当前的计划是年底前学完N1的考前对策，目前还有很多的书要看。</p><hr><blockquote><p>8月底的补充：8月27日和同事又有了一次线下麻将，然而麻将最终仍然是看运气的，更别说没有番数要求使得牌局变成了比速度的游戏😰还没轮到最后一摞牌堆就有人放铳或自摸。何况线下是投入真金白银的对局，不像游戏里只是四位率的增加而已。毕竟聚聚们的起手我就跟不上，被发牌姬针对的情况实在太多。</p></blockquote><h2 id="个人收集到的麻将教程">个人收集到的麻将教程</h2><p>自己的实践确实比不过大数据分析下的牌谱经验。麻将有一个好处，牌打错了可以选择流局放弃和牌，每一局的持续时间也不长，对于前期不注重算分只想着和牌的新手，意味着试错成本很低。但是线上麻将无法保证自己匹配到的是计算得失的高手，被新手乱打和大牌确实是一件让人沮丧的事情。这种情况下实践不如科学麻将总结到位。</p><p>感觉有一些麻将资料值得多看几遍，至少要给自己点信心。</p><ol><li>教学类视频<br><a href="https://www.youtube.com/c/%E6%98%9F%E9%87%8EPoteto/videos">星野Poteto</a><br><a href="https://www.youtube.com/channel/UCpUXhakFVdqUvcuunBciaew">魔女日麻教程(粤语听不懂)</a><br><a href="https://space.bilibili.com/2899425">B站up主汉化「麻将的职人」系列</a></li><li>教学类文章<br><a href="https://bbs.nga.cn/read.php?tid=24964074&amp;page=1">魔女BLOG初中级日麻讲座(简中翻译版PDF)</a><br><a href="https://zh.wikipedia.org/wiki/%E5%90%AC%E7%89%8C">维基百科介绍的听牌案例</a><br><a href="https://www.bilibili.com/read/readlist/rl398453">B站连载《麻将技术教科书：不会放铳的打法》</a><br><a href="https://space.bilibili.com/680263/article">B站up主SonicFantasia介绍日麻规则及《天才麻将少女》中的规则介绍</a></li><li>日文教程<br><a href="http://mjall.jp/t0001/">麻将役牌介绍</a> 这个网站也有从零开始的文字教程</li><li>边打边学：Github上面也有一些分析牌效率的开源程序，罗列几款<br><a href="https://github.com/zyr17/MajsoulPaipuAnalyzer">获取近期的牌谱并计算得失分情况</a><br><a href="https://github.com/EndlessCheng/mahjong-helper">实时计算应该摸切哪张牌</a><br><a href="https://github.com/moxcomic/MajsoulAI">AI自动打麻将</a></li></ol>]]></content>
    
    
    <summary type="html">周围人只会打国标麻将，而我只会日本麻将</summary>
    
    
    
    <category term="Life" scheme="https://92rw.github.io/categories/Life/"/>
    
    
    <category term="虚度时间" scheme="https://92rw.github.io/tags/%E8%99%9A%E5%BA%A6%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>建站感言</title>
    <link href="https://92rw.github.io/posts/d0725f51.html"/>
    <id>https://92rw.github.io/posts/d0725f51.html</id>
    <published>2021-08-25T00:00:00.000Z</published>
    <updated>2023-10-02T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p>👏 欢迎来到我的小站呀，很高兴遇见你！🤝</p></div><h2 id="🏠-关于本站-👇">🏠 关于本站 👇</h2><p>原本只是想学一下markdown怎么写，没想到Github也能托管网址🌎，于是开始尝试这种模式</p><p>此网站根据Gridea创建，采用 <a href="https://github.com/850552586/gridea-theme-fog">fog</a> 主题，感谢诸多程序员大佬们的付出，让我可以专心内容创作。</p><div class="note warning flat"><p>更新：从2023年10月起，网站改为Butterfly主题的Hexo博客</p></div><h2 id="👨‍💻-建站经历-🌱">👨‍💻 建站经历 🌱</h2><p>能顺利建站多亏了众多前人的经验分享，把门槛降得很低，让我可以专注于内容创作</p><p><img src="https://static-resources.vercel.app/posts/Screenshot-previouswebsite.png" alt="博客"></p><p>原先基于Gridea的博客因为更换电脑，无法将文章同步到Github，又因2022年工作中的众多变故，导致没有时间对博客进行大刀阔斧的更新。改版前的博客文章停留在了2021年底，只有网站上线计时器的数字在逐渐增加。</p><p>在2023年8月想重新构建网站，在B站发现了 <a href="https://www.bilibili.com/av822767311">hexo-theme-Fomalhaut 主题开源视频</a>，当时我正在学习JavaWeb 阶段，不敢贸然处理众多不熟悉的 JavaScript 代码，因此直到 10 月份才完成了老网站的文章备份及网站上线，完成了现在的界面。</p><p>发在微博、推特的内容很容易被时间线吞噬，因为算法更关注于“当下”的时间切片。希望改版后的博客能更多地记录“我”与时间为友的故事，也回看一下“过去”踩过的坑、走过的路。</p><h2 id="⛹-转码之前🌉">⛹ 转码之前🌉</h2><p>大学期间第一次接触到 <a href="https://docs.jupyter.org/en/latest/">Jupyter Notebook</a>，可以分步骤加载的Python语句，结合 <a href="https://zhuanlan.zhihu.com/p/100020058">快捷键</a> 十分方便。</p><p>在 <a href="https://github.com/92rw/Office-tools">我的Github仓库</a> 留下了之前工作时写的简单Python代码。</p><h3 id="图片OCR">图片OCR</h3><p>目前汉字和英文使用天若OCR文字识别，但是其他语言却并没有那么方便。重命名文件也直接用FreeRename可视化操作，所以很多python简单教程里面的内容我都跳过了。然而其他外语的OCR却并非易事。<br>2021年初第一次接触 <a href="https://github.com/JaidedAI/EasyOCR">EasyOCR</a>，然而那会甚至连pip安装都不知道，只能找个OCR网站一个个导入图片再下载。现在写了个小程序可以直接离线OCR，十分方便。</p><p>这个程序的不足之处：原本是带着文字位置一起OCR的，现在只剩下一个个文字块。因此遇到跨行的文字，常常对应不上，也就只能省下来一个个查字母表打字的过程，对于大规模开展工作还是不够适用。</p><h3 id="便捷式填表">便捷式填表</h3><p>需要使用<a href="https://docs.xlwings.org/zh_CN/latest/quickstart.html">xlwings</a>来实现相关操作，B站有其官方教程的<a href="https://www.bilibili.com/video/av84875087">视频免费版</a>。使用起来比筑业云资料方便，主要是对文档内容的精确定位和修改，保证填入信息的一致性。<br>2020年8月的时候第一次用xlwings来写这种填表，到2021年的8月才想着把这个上传到github上存档。不仅发现自己当时没写说明文档导致自己记忆里完成的东西和实际有偏差，而且发现自己这几天想到的程序创意去年早就实践过了，看来程序一段时间不写就会忘。</p><h2 id="📬实践笔记🌁">📬实践笔记🌁</h2><ul><li><p>Live2d</p><p>回看之前建的网站，当时用的 Live2D 版本已经落后于时代太多，<a href="https://github.com/flyhunterl/jdonkey">血小板</a> 和鼠标的交互不到位，确实是一个影响交互效果的问题</p></li><li><p>Markdown</p><p>这个语法本身好掌握，但是提供的样式种类有限。在 <a href="https://www.fomal.cc/posts/2013454d.html">Markdown语法与外挂标签写法汇总</a> 有较为全面的总结</p></li><li><p>Vercel</p><p>除了另外新建一个项目保存静态文件，还将这些内容托管部署到 Vercel 页面中，如果以后网站上线域名，可以直接使用。</p></li><li><p>Github Action</p><p>在本地测试正常后，上传到 Github 私有仓库中，在通过该仓库的 Github Action 实现自动部署。因此不再需要担心本地没有文章留档，也不用担心更换电脑后 API key 丢失导致无法上传。</p></li></ul>]]></content>
    
    
    <summary type="html">本人转码和个人网站的建设感想</summary>
    
    
    
    <category term="Blog" scheme="https://92rw.github.io/categories/Blog/"/>
    
    
    <category term="个人网站" scheme="https://92rw.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
</feed>
